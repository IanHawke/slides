<!doctype html>
<html lang="en">
    <head>
        
            <meta charset="utf-8">
            <meta name="robots" content="noindex">
            <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
            <meta name="author" content="Ian Hawke" />
            <meta name="date" content="2022-01-20" />
        

        <title>Course Notes | Operational Research and Mathematical Computing</title>

        
    
    
            <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
            <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
            <link rel="stylesheet" href="../../static/styles.css">
            <link rel="stylesheet" id="customiseCSS" href="../../static/light.css">
            
            
        
    <link rel="stylesheet" id="customiseCodeCSS" href="../../static/pygmentize.light.css">
    <link rel="stylesheet" href="../../static/codemirror-5.26.0/lib/codemirror.css">
    <link rel="stylesheet" href="../../static/boole.css">
    <link rel="stylesheet" href="../../static/numbasEmbed.css">

    <link rel="stylesheet" href="../../static/bootstrap-toc.css?v=3">
    <link rel="stylesheet" href="../../static/print.css">


        
    
    
            <script defer src="https://code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
            <script defer src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
            <script defer src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
            <script defer src="../../static/mathjax_config.js"></script>
            <script type="text/javascript" id="MathJax-script" defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
            <script defer src="../../static/customisation.js"></script>
            <script defer src="../../static/mp4.js"></script>
            
            
        
    <script defer src="../../static/jquery.flexibleArea.js"></script>
    <script defer src="../../static/spin.min.js"></script>
    <script defer src="../../static/codemirror-5.26.0/lib/codemirror.js"></script>
    <script defer src="../../static/codemirror-5.26.0/mode/octave/octave.js"></script>
    <script defer src="../../static/codemirror-5.26.0/mode/python/python.js"></script>
    <script defer src="../../static/codemirror-5.26.0/mode/r/r.js"></script>
    <script defer src="../../static/boole.js"></script>
    <script defer src="../../static/numbasEmbed.js"></script>

    <script defer src="../../static/bootstrap-toc.js"></script>

    </head>
    <body data-spy="scroll" data-target="#chapterTOC" data-offset="50">
        
<div class="collapse" id="navbarToggleCustomise">
	<div class="bg-secondary text-white p-3">
		<form onsubmit="return false;" id="navbarCustomise">
			<div class="form-row">
				<label>Theme Customisation</label>
				<div id="themeSelector" class="form-group col-md-12">
					<button class="btn btn-dark mr-2" value="dark">Dark</button>
					<button class="btn btn-pastel mr-2" value="pastel">Pastel</button>
					<button class="btn btn-light mr-4" value="light">Light</button>
				</div>
			</div>
			<div class="form-row">
				<div class="form-group col-md-4">
					<label style="display: block" for="font-scale">Font size (<span id="font-size-display">100%</span>)</label>
					<input type="range" class="form-control-range col-9 mr-2" id="font-scale" min="50" max="600" value="100">
					<button id="font-scale-reset" class="btn btn-sm">Reset</button>
				</div>
				<div class="form-group col-md-4">
					<label style="display: block" for="p-space">Spacing (<span id="p-space-display">100%</span>)</label>
					<input type="range" class="form-control-range col-9 mr-2" id="p-space" min="0" max="600" value="100">
					<button id="p-space-reset" class="btn btn-sm">Reset</button>
				</div>
			</div>
		</form>
	</div>
</div>

<nav aria-label="breadcrumb">
	<ul class="breadcrumb">
		<li class="breadcrumb-item">
			<a href="../../index.html">Operational Research and Mathematical Computing</a>
		</li>
		
		<li class="breadcrumb-item">
			<a href="../../notes/index.html">Notes</a>
		</li>
		
		<li class="breadcrumb-item active">
			Course Notes
		</li>
		<li class="ml-auto">
			<button class="navbar-toggler p0" type="button" data-toggle="collapse" data-target="#navbarToggleCustomise" aria-controls="navbarToggleCustomise" aria-expanded="false" aria-label="Toggle customisations panel">
				<i class="fa fa-cog" aria-hidden="true" title="Toggle customisations panel"></i> <span class="sr-only">Toggle customisations panel</span>
			</button>
		</li>
	</ul>
</nav>


        <header>
            
            
        </header>
        <main>
            
    <div class="container mt-3">
        <div class="row">
            
            <div id="sidebar" class="col-md-3">
                <nav class="mb-3" id="chapterTOC" data-toggle="toc">
                    <ul class="nav navbar-nav">
                        
                        
                        
                        <li><a id="pdf-link" class="nav-link" href="../../notes/course_notes/pdf/course_notes.pdf" target="_blank"><i class="fa fa-file-pdf-o" aria-hidden="true" title="Download as PDF"></i>&nbsp;Download as PDF</a></li>
                        
                    </ul>
                </nav>
            </div>
            <div id="content" class="col-md-9"> 
            
            
<!-- Latex Chapter/Part -->
<h1 id="chap:intro">Introduction</h1>
<section class="section">
<h2 id="sec:intro:optimisation">1.1 Optimisation</h2>
<p>
Optimisation is the mathematical procedure for finding the best choice of a set of variables subject to a range of constraints. It is a huge subject, and we will focus on two specific model problems as motivation. 
</p>
<p>
The first is the <em>diet problem</em>. We have a population that we want to keep healthy. We assume they are isolated, or resource limited in some way: think of astronauts, or explorers at sea, or a population at war. That means we want to provide food that meets their essential nutritional needs (enough energy, protein, and so on) whilst minimising its cost (which might be in terms of money, or weight, or volume, or something else). The best choice has the smallest cost. The constraints we need to satisfy are the essential nutritional needs. 
</p>
<p>
The second is the <em>shortest path problem</em>. We want to travel between two points with the minimum cost. We are thinking of a road or other transport network as the underlying example here. The best choice again has the smallest cost, which again might be in terms of money, or time, or distance. The constraints are the costs needed to go between any two underlying points, or along one single path, on the network. 
</p>
<section class="subsection">
<h3 id="sec:intro:optimisation:purpose">1.1.1 Purpose of these notes</h3>
<p>
These notes will give the minimum expected material for this course. They are mainly here to develop the theory and the analysis. For (much) more detail see the books 
</p>
<ol class="enumerate" id="a0000000003" style="list-style: none">
<li id="a0000000004" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
<em>Operations Research</em>, Winston, QA264.2 WIN. 
</p>
</li>
<li id="a0000000005" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
<em>Linear Programming</em>, Chvátal, QA265 CHV. 
</p>
</li>
</ol>
<p>
 Neither are needed, but those (and other similar books in the library and elsewhere) will give many additional ideas, examples, and exercises. 
</p>
</section><section class="subsection">
<h3 id="sec:intro:optimisation:links">1.1.2 Links to other modules</h3>
<p>
Whilst it may seem that a modules whose purpose is finding extreme values would naturally link with calculus, this is in fact only a small link. The main connection will be to Linear Algebra, particularly the use of matrices and vectors to formulate the problem and for key steps in the arguments. You will need to be comfortable with matrices and matrix operations, linear independence, and basis vectors. If in doubt refer to your Linear Algebra notes.  
</p>
</section>
</section><!-- Latex Chapter/Part -->
<h1 id="chap:lp">Linear programming</h1>
<section class="section">
<h2 id="sec:lp:problem">2.1 The problem</h2>
<p>
We start with a minimal <em>diet problem</em>. We have three types of food available to us: bread, milk, and eggs. We have three nutrients we need above certain minimum levels: carbohydrates, proteins, and vitamins. We want to minimise the cost of the food we need whilst ensuring we get enough nutrients. 
</p>
<section class="subsection">
<h3 id="sec:lp:problem:words">2.1.1 The problem in words</h3>
<p>
The example numbers we will use are as follows. The unit cost (cost in GB pounds per 100 gram serving) of each food type is 
</p>
<div class="centered"> <table class="tabular">
<tr><td colspan="" rowspan="" style="text-align:left; border-right:1px solid black"><p>
 Food 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 Cost 
</p>
</td>
</tr>
<tr><td colspan="" rowspan="" style="border-top-style:solid; border-top-color:black; border-top-width:1px; text-align:left; border-right:1px solid black"><p>
Bread 
</p>
</td>
<td colspan="" rowspan="" style="border-top-style:solid; border-top-color:black; border-top-width:1px; text-align:right"><p>
 2.5 
</p>
</td>
</tr>
<tr><td colspan="" rowspan="" style="text-align:left; border-right:1px solid black"><p>
Milk 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 1.2 
</p>
</td>
</tr>
<tr><td colspan="" rowspan="" style="text-align:left; border-right:1px solid black"><p>
Eggs 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 0.8 
</p>
</td>
</tr>
</table> </div>
<p>
 The amount (in grams) of each nutrient per unit (100 gram serving) of food is 
</p>
<div class="centered"> <table class="tabular">
<tr><td colspan="" rowspan="" style="text-align:left; border-right:1px solid black"><p>
 Food 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 Carbs 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 Proteins 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 Vitamins 
</p>
</td>
</tr>
<tr><td colspan="" rowspan="" style="border-top-style:solid; border-top-color:black; border-top-width:1px; text-align:left; border-right:1px solid black"><p>
Bread 
</p>
</td>
<td colspan="" rowspan="" style="border-top-style:solid; border-top-color:black; border-top-width:1px; text-align:right"><p>
 300 
</p>
</td>
<td colspan="" rowspan="" style="border-top-style:solid; border-top-color:black; border-top-width:1px; text-align:right"><p>
 5 
</p>
</td>
<td colspan="" rowspan="" style="border-top-style:solid; border-top-color:black; border-top-width:1px; text-align:right"><p>
 0.07 
</p>
</td>
</tr>
<tr><td colspan="" rowspan="" style="text-align:left; border-right:1px solid black"><p>
Milk 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 30 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 50 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 0.02 
</p>
</td>
</tr>
<tr><td colspan="" rowspan="" style="text-align:left; border-right:1px solid black"><p>
Eggs 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 20 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 90 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 0.12 
</p>
</td>
</tr>
</table> </div>
<p>
 To stay healty, the daily diet should contain at least the minimum quantity of each nutrient, which is 
</p>
<div class="centered"> <table class="tabular">
<tr><td colspan="" rowspan="" style="text-align:left; border-right:1px solid black"><p>
 Nutrient 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 Minimum quantity 
</p>
</td>
</tr>
<tr><td colspan="" rowspan="" style="border-top-style:solid; border-top-color:black; border-top-width:1px; text-align:left; border-right:1px solid black"><p>
Carbs 
</p>
</td>
<td colspan="" rowspan="" style="border-top-style:solid; border-top-color:black; border-top-width:1px; text-align:right"><p>
 300 
</p>
</td>
</tr>
<tr><td colspan="" rowspan="" style="text-align:left; border-right:1px solid black"><p>
Proteins 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 600 
</p>
</td>
</tr>
<tr><td colspan="" rowspan="" style="text-align:left; border-right:1px solid black"><p>
Vitamins 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 1 
</p>
</td>
</tr>
</table> </div>
</section><section class="subsection">
<h3 id="sec:lp:problem:equations">2.1.2 The problem as equations</h3>
<p>
We will now abstract away the details to construct a problem to solve. 
</p>
<p>
The variables we care about are the number of servings of each food stuff. We denote these <script type="math/tex">x_ B, x_ M, x_ E</script> for the number of servings of bread, milk, and eggs respectively. These are real numbers (we can eat a fraction of a serving), but cannot be negative (we cannot eat a negative amount of food). Hence 
</p>
<div class="eqn" id="a0000000006">
<script type="math/tex; mode=display">\begin{equation}x_ B, x_ M, x_ E \ge 0.\tag{2.1}\end{equation}</script>
</div>
<p>
The total cost of the diet is the sum of the unit costs multiplied by the number of servings in the diet. This is the <em>objective function</em> that we want to minimise. Hence 
</p>
<div class="eqn" id="a0000000007">
<script type="math/tex; mode=display">\begin{equation}\min 2.5 x_ B + 1.2 x_ M + 0.8 x_ E\tag{2.2}\end{equation}</script>
</div>
<p>
 is the total cost to be minimised. 
</p>
<p>
Finally, we have the constraints, which are the nutritional needs for the diet. Each separate nutrient gets its own equation. The total amount of each nutrient in the diet is the amount of nutrients per unit serving multiplied by the number of servings. Therefore the constraints are 
</p>
<div class="eqn" id="a0000000008">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{rcrcrcl@{\quad }l} 300 x_ B & +&  30 x_ M & +&  20 x_ E & \ge &  300 &  \text{: minimum carbs}, \\ 5 x_ B & +&  50 x_ M & +&  90 x_ E & \ge &  600 &  \text{: minimum proteins}, \\ 0.07 x_ B & +&  0.02 x_ M & +&  0.12 x_ E & \ge &  1 &  \text{: minimum vitamins}. \end{array}\tag{2.3}\end{equation}</script>
</div>
<p>
Typically the mathematical problem is summarized as 
</p>
<div class="eqn" id="a0000000009">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcrcrcl} \min &  2.5 x_ B & +&  1.2 x_ M & +&  0.8 x_ E & & \\ \text{subject to} &  300 x_ B & +&  30 x_ M & +&  20 x_ E & \ge &  300 \\ &  5 x_ B & +&  50 x_ M & +&  90 x_ E & \ge &  600 \\ &  0.07 x_ B & +&  0.02 x_ M & +&  0.12 x_ E & \ge &  1 \\ &  x_ B, & &  x_ M, & &  x_ E & \ge &  0. \end{array}\tag{2.4}\end{equation}</script>
</div>
</section><section class="subsection">
<h3 id="sec:lp:problem:general">2.1.3 A more general form</h3>
<p>
The specific coefficients are needed to solve the problem, but obscure some of the mathematical structure. We introduce more general notation to make the structure clearer. First, the number of constraints will be denoted <script type="math/tex">m</script> (this is the number of nutrients in this example). Next, the number of foods will be denoted <script type="math/tex">n</script> (this is the number of variables in the objective function). Then the problem can be written as 
</p>
<div class="eqn" id="a0000000010">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl@{\quad }l} \min &  \sum ^ n_{j=1} c_ j x_ j & & & \\ \text{subject to} &  \sum ^ n_{j=1} a_{ij} x_ j &  \ge &  b_ j &  \forall i = 1, \dots , m \\ &  x_ j &  \ge &  0 &  \forall j = 1, \dots , n. \end{array}\tag{2.5}\end{equation}</script>
</div>
<p>
 The coefficients are written <script type="math/tex">a_{ij}</script> (the amount of the <script type="math/tex">i^{\text{th}}</script> nutrient per unit of the <script type="math/tex">j^{\text{th}}</script> food), <script type="math/tex">b_ j</script> (the daily required amount of the <script type="math/tex">j^{\text{th}}</script> nutrient), and <script type="math/tex">c_ j</script> (the cost of the <script type="math/tex">j^{\text{th}}</script> food). 
</p>
</section>
</section><section class="section">
<h2 id="sec:lp:graphical">2.2 The graphical solution</h2>
<p>
We will simplify the problem even further to illustrate the key points of the solution method. Restrict to two variables (for example, consider only bread and eggs, as no milk is available). We will look at the simple problem 
</p>
<div class="eqn" id="a0000000011">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcrcl} \max &  0.02 x_ A & +&  0.03 x_ B & & \\ \text{subject to} &  x_ A & +&  x_ B & \le &  10 \\ &  x_ A & & & \le &  7 \\ & & &  x_ B & \le &  5 \\ &  x_ A, & &  x_ B & \ge &  0. \end{array}\tag{2.6}\end{equation}</script>
</div>
<p>
 This is a problem with three constraints (<script type="math/tex">m=3</script>) and two variables (<script type="math/tex">n=2</script>), and the coefficients can be read off from the equations (for example, <script type="math/tex">c = (0.02, 0.03)</script>). Note that key points of the problem are reversed compared to the diet problem: we are maximising, not minimising, and the constraints are less-than-or-equals rather than greater-than-or-equals. 
</p>
<p>
Each of the constraints describes a line in <script type="math/tex">\mathbb {R}^2</script> which splits the plane into two regions. In one region the constraint is satisfied; in the other it is not. We want to <em>draw</em> the region where all the constraints are satisfied. This is the <em>feasible region</em>. An example is in figure <a class="ref" href="../../notes/course_notes/index.html#fig:lp:graphical:all">2.1</a>. 
</p>
<figure id="fig:lp:graphical:all">
<p>
<img alt="The feasible region (shaded blue) constructed from the constraints (red dashed lines, with arrows pointing to which side is feasible) for a problem with two variables xA, xB." src="../../notes/course_notes/images/img-0002.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.1</span>
<span class="caption_text">The feasible region (shaded blue) constructed from the constraints (red dashed lines, with arrows pointing to which side is feasible) for a problem with two variables <script type="math/tex">x_ A, x_ B</script>.</span>
</figcaption>
</figure>
<p>
We want to find the point in the feasible region where the objective function is maximised (in this case: in the diet problem, we want to minimise). The <em>level curves</em> of the objective function are lines where <script type="math/tex">f(x) = 0.02 x_ A + 0.03 x_ B = z</script> are constant. These are straight lines which we can also plot. We also need the line that is orthogonal to the level curves: this is the gradient of the objective function <script type="math/tex">\nabla f</script> which, in this case, is <script type="math/tex">(0.02, 0.03)</script>. For linear problems we generally have <script type="math/tex">\nabla f = c</script>. 
</p>
<p>
Our solution method is then as follows. Start from some point within the feasible region (for example, the origin). Move in the direction of the gradient <script type="math/tex">\nabla f</script> that increases the objective function <script type="math/tex">z</script>. Draw level curves through this point. Each point that intersects the feasible region is a valid solution to the problem with the value <script type="math/tex">z</script> of the objective function. The last level curve (as we move along the gradient vector) that we can draw will give us the optimal value with its optimal solution <script type="math/tex">x^*</script>. This is illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:lp:level_curves">2.2</a>. 
</p>
<p>
Note that the solution we find has to be at a <em>corner</em> or <em>vertex</em> of the feasible region. Whilst the graphical solution only works for problems with two variables, the intuition (using the gradient and looking at vertices of the feasible region) extends to the general case. 
</p>
<figure id="fig:lp:level_curves">
<p>
<img alt="The optimal solution (red dot) is the last point in the feasible region (shaded blue) crossed by a level curve (black dashed lines) when moving in the direction of increasing objective function (the arrow pointing in the direction ∇f = c)." src="../../notes/course_notes/images/img-0004.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.2</span>
<span class="caption_text">The optimal solution (red dot) is the last point in the feasible region (shaded blue) crossed by a level curve (black dashed lines) when moving in the direction of increasing objective function (the arrow pointing in the direction <script type="math/tex">\nabla f = c</script>).</span>
</figcaption>
</figure>
</section><section class="section">
<h2 id="sec:lp:properties">2.3 Properties</h2>
<p>
Before we construct the general solution method it is useful to look at the form and structure of the problem. This is because there are multiple ways of looking at the problem, each of which is useful in different cases. There are also rules to transform between the cases. 
</p>
<section class="subsection">
<h3 id="sec:lp:properties:forms">2.3.1 The different forms</h3>
<section class="subsubsection">
<h4 id="a0000000012">Canonical form</h4>
<p>
This is the form used so far: 
</p>
<div class="eqn" id="a0000000013">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl@{\quad }l} \max &  \sum ^ n_{j=1} c_ j x_ j & & & \\ \text{subject to} &  \sum ^ n_{j=1} a_{ij} x_ j &  \le &  b_ j &  \forall i = 1, \dots , m \\ &  x_ j &  \ge &  0 &  \forall j = 1, \dots , n. \end{array}\tag{2.7}\end{equation}</script>
</div>
<p>
 This is a maximisation problem, with the inequalities being less-than’s. 
</p>
</section><section class="subsubsection">
<h4 id="a0000000014">Standard form</h4>
<p>
This is a new form: 
</p>
<div class="eqn" id="a0000000015">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl@{\quad }l} \min &  \sum ^ n_{j=1} c_ j x_ j & & & \\ \text{subject to} &  \sum ^ n_{j=1} a_{ij} x_ j &  = &  b_ j &  \forall i = 1, \dots , m \\ &  x_ j &  \ge &  0 &  \forall j = 1, \dots , n. \end{array}\tag{2.8}\end{equation}</script>
</div>
<p>
 This is a minimisation problem. We no longer have inequalities, but only equalities. 
</p>
</section><section class="subsubsection">
<h4 id="a0000000016">Simplified canonical form</h4>
<p>
This is the simplification of the canonical form we have used so far: 
</p>
<div class="eqn" id="a0000000017">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl@{\quad }l} \max &  \sum ^ n_{j=1} c_ j x_ j & & & \\ \text{subject to} &  \sum ^ n_{j=1} a_{ij} x_ j &  \le &  b_ j &  \forall i = 1, \dots , m. \end{array}\tag{2.9}\end{equation}</script>
</div>
<p>
 The key difference with canonical form is that we do not impose the variables to be non-negative. 
</p>
</section><section class="subsubsection">
<h4 id="a0000000018">Matrix form</h4>
<p>
This is the canonical form written in the more compact matrix notation: 
</p>
<div class="eqn" id="a0000000019">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl} \max &  c x & & \\ \text{subject to} &  A x &  \le &  b \\ &  x &  \ge &  0. \end{array}\tag{2.10}\end{equation}</script>
</div>
<p>
 Here <script type="math/tex">A \in \mathbb {R}^{m \times n}</script> is a matrix with entries <script type="math/tex">a_{ij}</script>, and <script type="math/tex">c, x \in \mathbb {R}^ n</script> and <script type="math/tex">b \in \mathbb {R}^ m</script> are vectors with entries <script type="math/tex">c_ j, x_ j</script> and <script type="math/tex">b_ j</script> respectively. Note that in the objective function we have written 
</p>
<div class="eqn" id="a0000000020">
<script type="math/tex; mode=display">\begin{equation}c x = c \cdot x = \sum _ j c_ j x_ j\tag{2.11}\end{equation}</script>
</div>
<p>
 for the inner product between the vector <script type="math/tex">c</script> and the vector <script type="math/tex">x</script>. 
</p>
<p>
This matrix form is useful for its compactness and the links to Linear Algebra concepts it allows us to make. 
</p>
</section>
</section><section class="subsection">
<h3 id="sec:lp:properties:transforms">2.3.2 Transformation rules</h3>
<p>
There are a range of rules that allow us to transform between, for example, canonical and standard form, or to change a problem in neither standard form into one of the standard forms. 
</p>
<ol class="enumerate" id="a0000000021" style="list-style: none">
<li id="a0000000022" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
Convert between maximisation and minimisation: 
</p>
<div id="a0000000023">
<div class="eqnarrayid" id="a0000000024"></div><div class="eqnarrayid" id="a0000000025"></div><script type="math/tex; mode=display">
\begin{align}
\tag{2.12} \max c x &  \implies &  - \min ( - c x), \\ 
\tag{2.13}\min c x &  \implies &  - \max ( - c x). 
\end{align}
</script>
</div>
</li>
<li id="a0000000026" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
Change direction of an inequality: 
</p>
<div id="a0000000027">
<div class="eqnarrayid" id="a0000000028"></div><div class="eqnarrayid" id="a0000000029"></div><script type="math/tex; mode=display">
\begin{align}
\tag{2.14} a x & \le b &  \implies & &  - a x &  \ge - b, \\ 
\tag{2.15}a x & \ge b &  \implies & &  - a x &  \le - b. 
\end{align}
</script>
</div>
</li>
<li id="a0000000030" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		3.
	</span>
<p>
Turn an equation into two inequalities: 
</p>
<div class="eqn" id="a0000000031">
<script type="math/tex; mode=display">\begin{equation}a x = b \implies a x \ge b \;  \text{and} \;  a x \le b.\tag{2.16}\end{equation}</script>
</div>
</li>
<li id="a0000000032" value="4">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		4.
	</span>
<p>
Turn an inequality into an equation: 
</p>
<ol class="enumerate" id="a0000000033" style="list-style: none">
<li id="a0000000034" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(a)
	</span>
<p>
For <script type="math/tex">\le </script> inequalities, introduce <script type="math/tex">s \ge 0</script>, a <em>slack</em> variable. Then 
</p>
<div class="eqn" id="a0000000035">
<script type="math/tex; mode=display">\begin{equation}a x \le b \implies a x + s = b, \;  \text{with} \;  s \ge 0.\tag{2.17}\end{equation}</script>
</div>
</li>
<li id="a0000000036" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(b)
	</span>
<p>
For <script type="math/tex">\ge </script> inequalities, introduce <script type="math/tex">s \ge 0</script>, a <em>surplus</em> variable. Then 
</p>
<div class="eqn" id="a0000000037">
<script type="math/tex; mode=display">\begin{equation}a x \ge b \implies a x - s = b, \;  \text{with} \;  s \ge 0.\tag{2.18}\end{equation}</script>
</div>
</li>
</ol>
</li>
<li id="a0000000038" value="5">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		5.
	</span>
<p>
Turn any variable <script type="math/tex">x_ j</script> without a sign restriction into two variables <script type="math/tex">x_ j^{\pm } \ge 0</script>, where <script type="math/tex">x_ j = x_ j^+ - x_ j^-</script>. 
</p>
</li>
</ol>
<p>
It is important to note that a number of these steps introduce additional variables and constraints. The exact number of variables and constraints are therefore linked to the form in which we write the problem, and are not properties of the problem itself. 
</p>
</section>
</section><section class="section">
<h2 id="a0000000039">2.4 Geometry of linear programming</h2>
<section class="subsection">
<h3 id="a0000000040">2.4.1 Setup</h3>
<p>
For this section we will work with the simplified canonical form in matrix notation, 
</p>
<div class="eqn" id="a0000000041">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl} \max &  c x & & \\ \text{subject to} &  A x &  \le &  b \\ &  x & &  \text{free}. \end{array}\tag{2.19}\end{equation}</script>
</div>
<p>
 We can write any non-negativity constraint as <script type="math/tex">e_{(j)} x \le 0</script>, where <script type="math/tex">e_{(j)}</script> is a vector that is zero in all entries except the <script type="math/tex">j^{\text{th}}</script>, where it is 1. This additional constraint can be embedded in the matrix form as an additional row in <script type="math/tex">A x \le b</script>. 
</p>
</section><section class="subsection">
<h3 id="a0000000042">2.4.2 Purpose</h3>
<p>
Start by remembering the graphical solution method. We argued that the optimal solution had to lie on a vertex of the feasible region. We also argued that we could sort these points using the gradient of the objective function. 
</p>
<p>
The purpose of this section is to prove (at some level of rigour) that this intuition extends away two variables, <script type="math/tex">n=2</script>, where the feasible region is a subset of the plane <script type="math/tex">\mathbb {R}^2</script>, to the general case where the feasible region is a subset of <script type="math/tex">\mathbb {R}^ n</script>. That is, we want to show that the optimal solution lies on a vertex of this feasible region. 
</p>
</section><section class="subsection">
<h3 id="a0000000043">2.4.3 Fundamental theorem of Linear Programming</h3>
<p>
<div class="thmwrapper thm_thmwrapper" id="a0000000044">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">4.1</span>
<span class="thmtitle thm_thmtitle">(Fundamental theorem)</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
 Let <script type="math/tex">P = \{  x \in \mathbb {R}^ n \colon A x \le b \} </script> and consider the linear program <script type="math/tex">\max \{  c x \colon x \in P \} </script>. If <script type="math/tex">P</script> is non-empty, the linear program either admits an optimal solution <script type="math/tex">x^*</script> corresponding to one of its vertices, or it is unbounded. 
</p>
</div>
</div>
</p>
<p>
Before we consider the proof let us look at what this says. The region <script type="math/tex">P</script> defined in the theorem is the feasible region. We have constructed the subset of <script type="math/tex">\mathbb {R}^ n</script> in which the constraints are satisfied. As noted in the theorem, it may be that there are no points where the constraints are satisfied (“if <script type="math/tex">P</script> is non-empty”): we ignore that case. It is also possible that the feasible region is unbounded and the objective function can increase without limit: this case (where the linear program is unbounded) also needs checking. 
</p>
<p>
To prove this theorem we need to be able to characterise any point in <script type="math/tex">P</script> in terms of its vertices in some way. To do this, we need a number of definitions and preliminary results. 
</p>
<section class="subsubsection">
<h4 id="a0000000045">Definitions</h4>
<p>
Consider a single inequality <script type="math/tex">a_ i x \le b_ i</script>. This splits <script type="math/tex">\mathbb {R}^ n</script> into two pieces. Define <script type="math/tex">\{  x \in \mathbb {R}^ n \colon a_ i x \le b_ i \} </script> to be the <em>halfspace</em> of points satisfying the inequality. Further define <script type="math/tex">\{  x \in \mathbb {R}^ n \colon a_ i x = b_ i \} </script> to be the <em>hyperplane</em> of points satisfying the inequality as an equation. The hyperplane bounds the halfspace. The vector <script type="math/tex">a_ i</script> is orthogonal to the hyperplane and points out of the halfspace. This is illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:lp:geom:hyperplane">2.3</a>. 
</p>
<figure id="fig:lp:geom:hyperplane">
<p>
<img alt="A hyperplane splitting Rn into two pieces. The halfspace (shaded blue) is where the inequality is satisfied. ai is orthogonal to the hyperplane." src="../../notes/course_notes/images/img-0006.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.3</span>
<span class="caption_text">A hyperplane splitting <script type="math/tex">\mathbb {R}^ n</script> into two pieces. The halfspace (shaded blue) is where the inequality is satisfied. <script type="math/tex">a_ i</script> is orthogonal to the hyperplane.</span>
</figcaption>
</figure>
<p>
The feasible region <script type="math/tex">P = \{  x \in \mathbb {R}^ n \colon A x \le b \} </script> is obtained by intersecting the <script type="math/tex">m</script> halfspaces for each inequality. The intersection of a finite number of halfspaces is called a <em>polyhedron</em>. Thus the feasible region is a polyhedron. 
</p>
<p>
Given <script type="math/tex">k</script> points <script type="math/tex">x_1, \dots , x_ k \in \mathbb {R}^ n</script>, their <em>convex combinations</em> are all the points <script type="math/tex">\{  y \} </script>, with 
</p>
<div class="eqn" id="a0000000046">
<script type="math/tex; mode=display">\begin{equation}y = \sum _{i=1}^ k \lambda _ i x_ i,\tag{2.20}\end{equation}</script>
</div>
<p>
 with the restrictions 
</p>
<div id="a0000000047">
<div class="eqnarrayid" id="a0000000048"></div><div class="eqnarrayid" id="a0000000049"></div><script type="math/tex; mode=display">
\begin{align}
\tag{2.21} \sum _{i=1}^ k \lambda _ i & =1, \\ 
\tag{2.22}\lambda _1, \dots , \lambda _ k &  \ge 0. 
\end{align}
</script>
</div>
<p>
 Intuitively, if the <script type="math/tex">x_ i</script> points are the vertices of a face of the polyhedron, the convex combinations describe all points on the face. Illustrations of convex combinations are in figure <a class="ref" href="../../notes/course_notes/index.html#fig:lp:geom:convex1">2.4</a> for two points and in figure <a class="ref" href="../../notes/course_notes/index.html#fig:lp:geom:convex2">2.5</a> for three points. 
</p>
<figure id="fig:lp:geom:convex1">
<p>
<img alt="All convex combinations of two points lie on the line segment between those two points." src="../../notes/course_notes/images/img-0008.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.4</span>
<span class="caption_text">All convex combinations of two points lie on the line segment between those two points.</span>
</figcaption>
</figure>
<figure id="fig:lp:geom:convex2">
<p>
<img alt="All convex combinations of three points form a triangle in a plane within Rn." src="../../notes/course_notes/images/img-0010.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.5</span>
<span class="caption_text">All convex combinations of three points form a triangle in a plane within <script type="math/tex">\mathbb {R}^ n</script>.</span>
</figcaption>
</figure>
<p>
The <em>conic combinations</em> are all the points without the restriction that the multipliers <script type="math/tex">\lambda _ i</script> sum to one. Intuitively they generate the hyperplane in full. For two points this is illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:lp:geom:conic">2.6</a>. 
</p>
<figure id="fig:lp:geom:conic">
<p>
<img alt="The conic combinations of two points generation a quadrant of R2." src="../../notes/course_notes/images/img-0012.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.6</span>
<span class="caption_text">The conic combinations of two points generation a quadrant of <script type="math/tex">\mathbb {R}^2</script>.</span>
</figcaption>
</figure>
<p>
A set <script type="math/tex">S \subseteq \mathbb {R}^ n</script> is <em>convex</em> if it contains the convex combinations of all of its elements, that is 
</p>
<div class="eqn" id="a0000000050">
<script type="math/tex; mode=display">\begin{equation}\lambda x_1 + (1 - \lambda ) x_2 \in S \quad \forall x_1, x_2 \in S \;  \text{and} \;  \forall \lambda \in [0, 1].\tag{2.23}\end{equation}</script>
</div>
<p>
 We think of this as meaning that the straight line segment linking <script type="math/tex">x_1, x_2 \in S</script> is contained within <script type="math/tex">S</script>. Within the plane <script type="math/tex">\mathbb {R}^2</script> a circle is convex and a “C” shape is not. These are illustrated in figures <a class="ref" href="../../notes/course_notes/index.html#fig:lp:geom:convex_set">2.7</a> and <a class="ref" href="../../notes/course_notes/index.html#fig:lp:geom:nonconvex_set">2.8</a> respectively. 
</p>
<figure id="fig:lp:geom:convex_set">
<p>
<img alt="A convex set has all points linked by line segments that lie within the set." src="../../notes/course_notes/images/img-0014.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.7</span>
<span class="caption_text">A convex set has all points linked by line segments that lie within the set.</span>
</figcaption>
</figure>
<figure id="fig:lp:geom:nonconvex_set">
<p>
<img alt="A non-convex set has some pair of points that are not linked by a line segment that lies within the set." src="../../notes/course_notes/images/img-0016.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.8</span>
<span class="caption_text">A non-convex set has some pair of points that are not linked by a line segment that lies within the set.</span>
</figcaption>
</figure>
<p>
For a given polyhedron <script type="math/tex">P</script>, a <em>vertex</em> <script type="math/tex">v</script> is a point that cannot be written as a convex combination of two other points <script type="math/tex">x, y</script> in <script type="math/tex">P</script> (with <script type="math/tex">v, x, y</script> all distinct). A <em>face</em> is any planar surface belonging to the boundary of <script type="math/tex">P</script>. A <em>facet</em> is any <script type="math/tex">n-1</script>-dimenional face. This is illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:lp:geom:vertices:facets">2.9</a>. 
</p>
<figure id="fig:lp:geom:vertices:facets">
<p>
<img alt="A vertex is a corner. The black circles are vertices; the red circle is not. A face is any planar part of the boundary. The blue lines are one dimenional faces; the blue shaded region is a two dimensional face. A facet is an (n-1)-dimesional face. The shaded region is a facet as well as a face, whilst the edges are not facets." src="../../notes/course_notes/images/img-0018.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.9</span>
<span class="caption_text">A vertex is a corner. The black circles are vertices; the red circle is not. A face is any planar part of the boundary. The blue lines are one dimenional faces; the blue shaded region is a two dimensional face. A facet is an <script type="math/tex">(n-1)</script>-dimesional face. The shaded region is a facet as well as a face, whilst the edges are not facets.</span>
</figcaption>
</figure>
<p>
For a set <script type="math/tex">S \subseteq \mathbb {R}^ n</script>, the vector <script type="math/tex">r \in \mathbb {R}^ n</script> is a <em>ray</em> if 
</p>
<div class="eqn" id="a0000000051">
<script type="math/tex; mode=display">\begin{equation}x_0 + \mu r \in S \quad \forall x_0 \in S \;  \text{and} \;  \forall \mu \ge 0.\tag{2.24}\end{equation}</script>
</div>
<p>
 This requires that the <em>semiline</em> (starting from <script type="math/tex">x_0</script> and moving in the direction of <script type="math/tex">r</script>) is completely contained in <script type="math/tex">S</script> (for all points <script type="math/tex">x_0 \in S</script>). 
</p>
<p>
An <em>extreme ray</em> is a ray that cannot be expressed as a conic combination of two other distinct rays <script type="math/tex">p, q</script>, where <script type="math/tex">r, p, q</script> are all distinct. This is illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:lp:geom:extreme_rays">2.10</a>. 
</p>
<figure id="fig:lp:geom:extreme_rays">
<p>
<img alt="The given set S is the blue shaded region, assumed to extend indefinitely down and to the right. The semilines r1 and r2 are extreme rays. The semiline r3 is a ray but not an extreme one." src="../../notes/course_notes/images/img-0020.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.10</span>
<span class="caption_text">The given set <script type="math/tex">S</script> is the blue shaded region, assumed to extend indefinitely down and to the right. The semilines <script type="math/tex">r_1</script> and <script type="math/tex">r_2</script> are extreme rays. The semiline <script type="math/tex">r_3</script> is a ray but not an extreme one.</span>
</figcaption>
</figure>
<p>
A set is <em>bounded</em> if the norm of all vectors in the set is bounded. That is, <script type="math/tex">\exists \delta \ge 0</script> such that <script type="math/tex">\|  x \|  \le \delta \;  \forall x \in S</script>. 
</p>
<p>
We call a bounded polyhedron a <em>polytope</em>. This is illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:lp:geom:polytope">2.11</a>. 
</p>
<figure id="fig:lp:geom:polytope">
<p>
<img alt="The shaded region on the left is bounded by the solid blue lines, and is therefore a polytope. The shaded region on the right is not bounded at the bottom and right and assumed to extend indefinitely. It is therefore not a polytope." src="../../notes/course_notes/images/img-0022.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.11</span>
<span class="caption_text">The shaded region on the left is bounded by the solid blue lines, and is therefore a polytope. The shaded region on the right is not bounded at the bottom and right and assumed to extend indefinitely. It is therefore not a polytope.</span>
</figcaption>
</figure>
</section>
</section><section class="subsection">
<h3 id="a0000000052">2.4.4 Key results</h3>
<p>
After that blizzard of definitions we can prove some key results. 
</p>
<p>
<div class="thmwrapper thm_thmwrapper" id="a0000000053">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">4.2</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
Polytopes have no rays. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000054">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
If a polytope had a ray it would contain a semiline <script type="math/tex">x_0 + \mu r</script> for all values of <script type="math/tex">\mu </script>. By increasing <script type="math/tex">\mu </script> we can increase <script type="math/tex">\|  x \| </script> without bound. This contradicts that a polytope must be bounded. 
</p>
</div>
</div>
<p>
<div class="thmwrapper thm_thmwrapper" id="a0000000055">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">4.3</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
The feasible region is convex. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000056">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
Work by contradiction. Assume that <script type="math/tex">P</script>, the polyhedron which is the feasible region, is not convex. Then there exists <script type="math/tex">x, y \in P</script> such that the line segment joining <script type="math/tex">x, y</script> has points not in <script type="math/tex">P</script>. Start at <script type="math/tex">x \in P</script> and move along the line segment until we reach the boundary of <script type="math/tex">P</script>. By construction this point must be in a hyperplane. By definition all points on one side of the hyperplane are in <script type="math/tex">P</script> and all points on the other side are not. As the line segment has not yet left <script type="math/tex">P</script> we have not yet reached <script type="math/tex">y</script>, so <script type="math/tex">y</script> is on the other side of the hyperplane to <script type="math/tex">x</script>. Therefore <script type="math/tex">y \not \in P</script>. This contradicts our assumption. 
</p>
</div>
</div>
<p>
Convexity makes constructing an algorithm to solve the linear program much simpler. Non-convex problems are much harder to solve. However, our main concern is linking the vertices to points in the interior in order to prove the fundamental theorem. 
</p>
<p>
<div class="thmwrapper thm_thmwrapper" id="a0000000057">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">4.4</span>
<span class="thmtitle thm_thmtitle">(Weyl-Minkowski theorem)</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
 For a subset <script type="math/tex">P \subseteq \mathbb {R}^ n</script>, the following statements are equivalent: 
</p>
<ul class="itemize" id="a0000000058">
<li id="a0000000059"> <p>
<script type="math/tex">P</script> is a non-empty polyhedron; 
</p>
</li>
<li id="a0000000060"> <p>
There are two sets, one of <script type="math/tex">k \ge 1</script> vertices <script type="math/tex">v_1, \dots , v_ k</script>, and another of <script type="math/tex">h \ge 0</script> extreme rays <script type="math/tex">r_1, \dots , r_ h</script>, such that any point <script type="math/tex">x \in P</script> can be written 
</p>
<div class="eqn" id="a0000000061">
<script type="math/tex; mode=display">\begin{equation}x = \sum _{i=1}^ k \lambda _ i v_ i + \sum _{j=1}^ h \mu _ j r_ j .\tag{2.25}\end{equation}</script>
</div>
</li>
</ul>
</div>
</div>
</p>
<p>
The proof of this theorem is complex and not our key purpose. The point, for our purpose, is that it allows us to express any point within <script type="math/tex">P</script> in terms of its vertices. This is illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:lp:geom:weyl_minkowski">2.12</a>. This is what we needed to prove the fundamental theorem. 
</p>
<figure id="fig:lp:geom:weyl_minkowski">
<p>
<img alt="The Weyl-Minkowski theorem says that we can express every point within a polyhedron in terms of some set of vertices (here ν1, ν2) and extreme rays (here r1, r2)." src="../../notes/course_notes/images/img-0024.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.12</span>
<span class="caption_text">The Weyl-Minkowski theorem says that we can express every point within a polyhedron in terms of some set of vertices (here <script type="math/tex">\nu _1, \nu _2</script>) and extreme rays (here <script type="math/tex">r_1, r_2</script>).</span>
</figcaption>
</figure>
</section><section class="subsection">
<h3 id="a0000000062">2.4.5 Proof of the Fundamental Theorem</h3>
<p>
<div class="thmwrapper thm_thmwrapper" id="a0000000063">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">4.5</span>
<span class="thmtitle thm_thmtitle">(Fundamental theorem)</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
 Let <script type="math/tex">P = \{  x \in \mathbb {R}^ n \colon A x \le b \} </script> and consider the linear program <script type="math/tex">\max \{  c x \colon x \in P \} </script>. If <script type="math/tex">P</script> is non-empty, the linear program either admits an optimal solution <script type="math/tex">x^*</script> corresponding to one of its vertices, or it is unbounded. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000064">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
Let <script type="math/tex">x \in P</script> be a point in the feasible region. Write 
</p>
<div class="eqn" id="a0000000065">
<script type="math/tex; mode=display">\begin{equation}x = \sum _{i=1}^ k \lambda _ i v_ i + \sum _{j=1}^ h \mu _ j r_ j\tag{2.26}\end{equation}</script>
</div>
<p>
 using the Weyl-Minkowski theorem. The values of <script type="math/tex">\lambda , \mu </script> are constrained to be non-negative, and additionally the values of <script type="math/tex">\lambda </script> must sum to one. 
</p>
<p>
We now want to <em>change variables</em> from <script type="math/tex">x</script> to <script type="math/tex">\lambda , \mu </script>. That is, we want to re-write our linear program in terms of the vector <script type="math/tex">(\lambda , \mu )</script>. First re-write the objective function as 
</p>
<div class="eqn" id="a0000000066">
<script type="math/tex; mode=display">\begin{equation}c x = \sum _{i=1}^ k \lambda _ i (c v_ i) + \sum _{j=1}^ h \mu _ j (c r_ j) .\tag{2.27}\end{equation}</script>
</div>
<p>
 This sums over every entry of the vector <script type="math/tex">(\lambda , \mu )</script>; the coefficients are the inner product of <script type="math/tex">c</script> with either a vertex <script type="math/tex">v_ i</script> or a ray <script type="math/tex">r_ j</script>. 
</p>
<p>
Next, write the constraints applied to <script type="math/tex">(\lambda , \mu )</script>. These are 
</p>
<div id="a0000000067">
<div class="eqnarrayid" id="a0000000068"></div><div class="eqnarrayid" id="a0000000069"></div><div class="eqnarrayid" id="a0000000070"></div><script type="math/tex; mode=display">
\begin{align}
\tag{2.28} \sum _{i=1}^ k \lambda _ i & =1, \\ 
\tag{2.29}\lambda _1, \dots , \lambda _ k & \ge 0, \\ 
\tag{2.30}\mu _1, \dots , \mu _ h & \ge 0. 
\end{align}
</script>
</div>
<p>
We are therefore solving the linear program given by maximsing over all points in the feasible region within <script type="math/tex">(\lambda , \mu )</script>-space. 
</p>
<p>
Now look at the objective function. If <script type="math/tex">c r_ j > 0</script> for some ray <script type="math/tex">r_ j</script> we can increase <script type="math/tex">\mu _ j</script>, and hence the objective function, arbitrarily. This means the linear program is unbounded. 
</p>
<p>
The alternative is that <script type="math/tex">c r_ j \le 0</script> for all rays. In this case the optimal solution requires <script type="math/tex">\mu _ j = 0</script> for all <script type="math/tex">j</script>, as any non-zero coefficient <script type="math/tex">\mu _ j</script> would only reduce the objective function. Therefore 
</p>
<div class="eqn" id="a0000000071">
<script type="math/tex; mode=display">\begin{equation}c x^* = \sum _{i=1}^ k \lambda _ i (c v_ i)\tag{2.31}\end{equation}</script>
</div>
<p>
 and the optimal value has to be a linear combination of the values taken by the objective function at vertices. This gives us a finite number of values to check, and we conclude that 
</p>
<div class="eqn" id="a0000000072">
<script type="math/tex; mode=display">\begin{equation}c x^* = \max _{i = 1, \dots , k} \{  c v_ i \} .\tag{2.32}\end{equation}</script>
</div>
<p>
 There is, then, an optimal solution corresponding to a vertex <script type="math/tex">v_ i</script>. 
</p>
</div>
</div>
</section><section class="subsection">
<h3 id="a0000000073">2.4.6 Sanity checks</h3>
<section class="subsubsection">
<h4 id="a0000000074">Interior points cannot be optimal</h4>
<p>
An alternative negative proof can show that interior points cannot be optimal. This does not show the link between vertices and optimal points, but gives more confidence. An illustration is in figure <a class="ref" href="../../notes/course_notes/index.html#fig:lp:geom:interior:feasible">2.13</a>. 
</p>
<p>
<div class="thmwrapper thm_thmwrapper" id="a0000000075">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">4.6</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
Any point <script type="math/tex">x</script> in the interior of <script type="math/tex">P</script> cannot be optimal. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000076">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
Work by contradiction. Assume there is a point <script type="math/tex">x</script> in the interior of <script type="math/tex">P</script> that is optimal. Construct a ball <script type="math/tex">B</script> of radius <script type="math/tex">\delta > 0</script> around <script type="math/tex">x</script>, <script type="math/tex">B = \{  y \colon \|  y - x \|  \le \delta \} </script>. We need <script type="math/tex">B \subseteq P</script> so that all points are within the feasible region. 
</p>
<p>
Now consider a point <script type="math/tex">w = x + \epsilon c</script> where <script type="math/tex">\epsilon </script> is small enough that <script type="math/tex">w \in B \subseteq P</script>. As <script type="math/tex">c</script> is the gradient of the objective function it must be the case that (for maximisation problems) the objective function at <script type="math/tex">w</script> is greater than at <script type="math/tex">x</script>. Therefore <script type="math/tex">x</script> is not optimal and we have a contradiction. 
</p>
</div>
</div>
<figure id="fig:lp:geom:interior:feasible">
<p>
<img alt="An interior point (red dot) of the feasible region (grey shaded region) cannot be optimal, as we can always construct a ball (blue shaded region) around it and improve the value of the objective function (whose level curves are the dashed lines) by moving along ∇f (the arrow)." src="../../notes/course_notes/images/img-0026.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.13</span>
<span class="caption_text">An interior point (red dot) of the feasible region (grey shaded region) cannot be optimal, as we can always construct a ball (blue shaded region) around it and improve the value of the objective function (whose level curves are the dashed lines) by moving along <script type="math/tex">\nabla f</script> (the arrow).</span>
</figcaption>
</figure>
</section><section class="subsubsection">
<h4 id="a0000000077">Non-vertices may be optimal</h4>
<p>
Note that it is possible for <em>multiple</em> vertices to have the same, optimal, value of the objective function. In this case points within the facet (in its <em>relative interior</em>) linking these vertices will have the same optimal value. This may occur when the facet is orthogonal to the gradient of the objective function, <script type="math/tex">c</script>. 
</p>
<p>
However, this does not matter. The theorem guarantees that <em>an</em> optimal solution can always be found at <em>some</em> vertex. In this case there are infinite optimal solutions obtained by convex combinations of the vertices of the facet, and all of the vertices are optimal. This is illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:lp:geom:interior:facet">2.14</a>. 
</p>
<figure id="fig:lp:geom:interior:facet">
<p>
<img alt="Points in the relative interior of a facet (the blue line) can be optimal if the level curve (dashed line) is constant within the facet so that ∇f is orthogonal to it. The value of the objective function is then the same at all points in the facet. If it is optimal, the vertices of the facet are then optimal (as is every point in the facet)." src="../../notes/course_notes/images/img-0028.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">2.14</span>
<span class="caption_text">Points in the relative interior of a facet (the blue line) can be optimal if the level curve (dashed line) is constant within the facet so that <script type="math/tex">\nabla f</script> is orthogonal to it. The value of the objective function is then the same at all points in the facet. If it is optimal, the vertices of the facet are then optimal (as is every point in the facet).</span>
</figcaption>
</figure>
</section>
</section><section class="subsection">
<h3 id="a0000000078">2.4.7 Brute force solutions</h3>
<p>
The fundamental theorem therefore gives us a method to find the optimal solution of a linear program. That is, we first identify all vertices of the feasible region. We then evaluate the objective region at each vertex. By enumeration we then find which is optimal. 
</p>
<p>
For example, consider the problem from the graphical solution section, 
</p>
<div class="eqn" id="a0000000079">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcrcl} \max &  0.02 x_ A & +&  0.03 x_ B & & \\ \text{subject to} &  x_ A & +&  x_ B & \le &  10 \\ &  x_ A & & & \le &  7 \\ & & &  x_ B & \le &  5 \\ &  x_ A, & &  x_ B & \ge &  0. \end{array}\tag{2.33}\end{equation}</script>
</div>
<p>
 This has five vertices from the intersections of the four constraints. 
</p>
<p>
In general we expect a feasible region with <script type="math/tex">n</script> variables and <script type="math/tex">m</script> constraints to be represented by a polyhedron with approximately 
</p>
<div class="eqn" id="a0000000080">
<script type="math/tex; mode=display">\begin{equation}\binom {m}{n} = \frac{m!}{n! (m - n)!} \simeq \frac{m^ m}{n^ n (m - n)^{m-n}}\tag{2.34}\end{equation}</script>
</div>
<p>
 vertices. The geometric growth of the number of vertices make enumeration impractical, even with modern computers.  
</p>
</section>
</section><!-- Latex Chapter/Part -->
<h1 id="chap:sorting">Sorting</h1>
<section class="section">
<h2 id="sec:sorting:motivation">3.1 The motivation</h2>
<p>
In the previous chapter we saw how a linear program could be solved. We can find every vertex of the feasible region and then evaluate the objective function at all vertices. By sorting this values we then have the optimal solution. 
</p>
<p>
However, we claimed that this method was impractically slow, as the computational cost can grow as <script type="math/tex">m^ m</script> (sometimes called exponentially, or geometrically). We should make this explicit. Assume that one operation (finding one vertex and computing the objective function there) takes one microsecond, <script type="math/tex">1 \mu \text{s}</script>. Then compare how long it would take if the computational cost were linear (grows as <script type="math/tex">m</script>), quadratic (grows as <script type="math/tex">m^2</script>), or geometric (grows as <script type="math/tex">2^ m</script> or as <script type="math/tex">m^ m</script>) as the number of vertices <script type="math/tex">m</script> increases: 
</p>
<div class="centered"> <table class="tabular">
<tr><td colspan="" rowspan="" style="text-align:left; border-right:1px solid black"><p>
 Vertices (<script type="math/tex">m</script>) 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 Linear (<script type="math/tex">m</script>) 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
 Quadratic (<script type="math/tex">m^2</script>) 
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
<script type="math/tex">2^ m</script>
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
<script type="math/tex">m^ m</script>
</p>
</td>
</tr>
<tr><td colspan="" rowspan="" style="border-top-style:solid; border-top-color:black; border-top-width:1px; text-align:left; border-right:1px solid black"><p>
<script type="math/tex">1</script>
</p>
</td>
<td colspan="" rowspan="" style="border-top-style:solid; border-top-color:black; border-top-width:1px; text-align:right"><p>
<script type="math/tex">1 \mu \text{s}</script>
</p>
</td>
<td colspan="" rowspan="" style="border-top-style:solid; border-top-color:black; border-top-width:1px; text-align:right"><p>
<script type="math/tex">1 \mu \text{s}</script>
</p>
</td>
<td colspan="" rowspan="" style="border-top-style:solid; border-top-color:black; border-top-width:1px; text-align:right"><p>
<script type="math/tex">1 \mu \text{s}</script>
</p>
</td>
<td colspan="" rowspan="" style="border-top-style:solid; border-top-color:black; border-top-width:1px; text-align:right"><p>
<script type="math/tex">1 \mu \text{s}</script>
</p>
</td>
</tr>
<tr><td colspan="" rowspan="" style="text-align:left; border-right:1px solid black"><p>
<script type="math/tex">10</script>
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
<script type="math/tex">10 \mu \text{s}</script>
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
<script type="math/tex">10^2 \mu \text{s}</script>
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
<script type="math/tex">\sim 10^3 \mu \text{s}</script>
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
<script type="math/tex">\sim 3 \text{ hours}</script>
</p>
</td>
</tr>
<tr><td colspan="" rowspan="" style="text-align:left; border-right:1px solid black"><p>
<script type="math/tex">100</script>
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
<script type="math/tex">100 \mu \text{s}</script>
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
<script type="math/tex">10^{-2} \text{s}</script>
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
<script type="math/tex">\sim 10^{22} \text{ years}</script>
</p>
</td>
<td colspan="" rowspan="" style="text-align:right"><p>
<script type="math/tex">\sim 10^{192} \text{ years}</script>
</p>
</td>
</tr>
</table> </div>
<p>
 We see that the power law cases (linear and quadratic) both complete in fractions of a second for a hundred vertices, whilst neither geometric case will complete within the lifetime of the universe. Note that Chvátal, writing around 1980, comments that problems with <script type="math/tex">m \ge 10^3</script> were being solved routinely. In modern usage linear programs with <script type="math/tex">m \ge 10^6</script> are being solved in under a minute by the best solvers. 
</p>
</section><section class="section">
<h2 id="sec:sorting:problem">3.2 The problem</h2>
<p>
The problem, for this chapter, is to understand how to analyse an algorithm. Once we can measure how fast, in principle, an algorithm completes its task, we can use this to compare different techniques. 
</p>
<p>
We will not apply this analysis to linear programming algorithms at first, as there is a simpler case at hand. That is the final step in our impractical algorithm for linear programs: sorting a list of numbers. 
</p>
<section class="subsection">
<h3 id="sec:sorting:problem:sorting">3.2.1 Sorting</h3>
<p>
The <em>sorting problem</em> is to take a list <script type="math/tex">a</script> of objects with a <em>partial order</em> <script type="math/tex">\le </script>, sort the list into non-decreasing order. 
</p>
<p>
The type of the objects is left unspecified. They could be real numbers or integers, which will be our standard examples. They could be letters or words. The key point is that it must be possible to compare any two objects in the list to give an order. That is, <script type="math/tex">\forall x, y \in a</script>, the comparison <script type="math/tex">x \le y</script> must be either true or false. A list containing all integers is fine. A list containing a mix of letters and numbers is not (without further assumptions). A list containing complex numbers is not fine either. 
</p>
<p>
We assume the list has length <script type="math/tex">n</script> and refer to the individual entries in the list as <script type="math/tex">a_ i</script>, where <script type="math/tex">i \in \{ 1, \dots , n \} </script> is the <em>index</em>. We are looking to construct a <em>permutation operator</em> <script type="math/tex">\pi \colon \{ 1, \dots , n \}  \to \{ 1, \dots , n \} </script> which is a bijective function on the indexes. The permutation operator tells us where to go in the original list to find the object at a given position in the sorted list. 
</p>
<p>
Formally, the problem is to find a permutation <script type="math/tex">\pi </script> such that 
</p>
<div class="eqn" id="a0000000081">
<script type="math/tex; mode=display">\begin{equation}a_{\pi (i)} \le a_{\pi (i+1)} \quad \forall i \in \{ 1, \dots , n \} .\tag{3.1}\end{equation}</script>
</div>
<p>
As a concrete example, consider the list <script type="math/tex">a = (7, 2, 2, 6, 1, 4)</script>. By eye we see the sorted list is <script type="math/tex">s = (1, 2, 2, 4, 6, 7)</script>. Looking at the indices we construct the permutation: 
</p>
<div class="eqn" id="a0000000082">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{cccccccc} a &  \colon &  7 &  2 &  2 &  6 &  1 &  4 \\ \text{index} &  \colon &  1 &  2 &  3 &  4 &  5 &  6 \end{array} \to \begin{array}{cccccccc} s &  \colon &  1 &  2 &  2 &  4 &  6 &  7 \\ \pi (\text{index}) &  \colon &  5 &  2 &  3 &  6 &  4 &  1 \end{array}\tag{3.2}\end{equation}</script>
</div>
</section>
</section><section class="section">
<h2 id="a0000000083">3.3 Algorithms</h2>
<p>
We look at three different sorting algorithms before introduing a detailed analysis. 
</p>
<section class="subsection">
<h3 id="a0000000084">3.3.1 Brute Force Sort</h3>
<p>
This is a two step process. 
</p>
<ol class="enumerate" id="a0000000085" style="list-style: none">
<li id="a0000000086" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
Enumerate all possible permutations <script type="math/tex">\pi </script> of length <script type="math/tex">n</script>. 
</p>
</li>
<li id="a0000000087" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
Return the first permutation giving a sorted list. 
</p>
</li>
</ol>
<p>
This is closely linked to the impractical algorithm introduced to solve the linear programming problem. 
</p>
<p>
It is possible that only one permutation sorts the list, and that (by bad luck) it is the last one constructed. Given a list with <script type="math/tex">n</script> items we can construct <script type="math/tex">n!</script> permutations of that list (consider how many positions the first object can take, then, having fixed the first, how many the second can take, and so on). For large <script type="math/tex">n</script> we have that <script type="math/tex">n! \sim n^ n</script>, and we have seen how rapidly that grows. 
</p>
</section><section class="subsection">
<h3 id="a0000000088">3.3.2 Selection sort</h3>
<p>
This is an iterative process. 
</p>
<ol class="enumerate" id="a0000000089" style="list-style: none">
<li id="a0000000090" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
Find the smallest object. 
</p>
</li>
<li id="a0000000091" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
Swap it with the object in position one (if strictly smaller). 
</p>
</li>
<li id="a0000000092" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		3.
	</span>
<p>
Find the next smallest object in the list; alternatively, consider the list <em>except</em> the first object. 
</p>
</li>
<li id="a0000000093" value="4">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		4.
	</span>
<p>
Swap it with the object in position two (if strictly smaller). 
</p>
</li>
<li id="a0000000094" value="5">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		5.
	</span>
<p>
Continue to the end of the list. 
</p>
</li>
</ol>
<p>
When implemented in code this algorithm requires two loops. The outer loop runs over the whole list and corresponds to the position we are going to swap the “smallest” object into. The inner loop is to find the smallest object, and runs over only part of the list. 
</p>
<p>
The steps for <script type="math/tex">a = (7, 2, 2, 6, 1, 4)</script> are as follows. When we find the smallest object it will be in the sublist denoted by square brackets: 
</p>
<ol class="enumerate" id="a0000000095" style="list-style: none">
<li id="a0000000096" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<ol class="enumerate" id="a0000000097" style="list-style: none">
<li id="a0000000098" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(a)
	</span>
<p>
: Smallest object in <script type="math/tex">([7, 2, 2, 6, 1, 4])</script> is <script type="math/tex">1</script> at index <script type="math/tex">5</script>. 
</p>
</li>
<li id="a0000000099" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(b)
	</span>
<p>
: Swap with object at index <script type="math/tex">1</script>, giving <script type="math/tex">(1, 2, 2, 6, 7, 4)</script>. 
</p>
</li>
</ol>
</li>
<li id="a0000000100" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<ol class="enumerate" id="a0000000101" style="list-style: none">
<li id="a0000000102" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(a)
	</span>
<p>
: Smallest object in <script type="math/tex">(1, [2, 2, 6, 7, 4])</script> is <script type="math/tex">2</script> at index <script type="math/tex">2</script>. 
</p>
</li>
<li id="a0000000103" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(b)
	</span>
<p>
: Do not swap as already at index <script type="math/tex">2</script>, giving <script type="math/tex">(1, 2, 2, 6, 7, 4)</script>. 
</p>
</li>
</ol>
</li>
<li id="a0000000104" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		3.
	</span>
<ol class="enumerate" id="a0000000105" style="list-style: none">
<li id="a0000000106" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(a)
	</span>
<p>
: Smallest object in <script type="math/tex">(1, 2, [2, 6, 7, 4])</script> is <script type="math/tex">2</script> at index <script type="math/tex">3</script>. 
</p>
</li>
<li id="a0000000107" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(b)
	</span>
<p>
: Do not swap as already at index <script type="math/tex">3</script>, giving <script type="math/tex">(1, 2, 2, 6, 7, 4)</script>. 
</p>
</li>
</ol>
</li>
<li id="a0000000108" value="4">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		4.
	</span>
<ol class="enumerate" id="a0000000109" style="list-style: none">
<li id="a0000000110" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(a)
	</span>
<p>
: Smallest object in <script type="math/tex">(1, 2, 2, [6, 7, 4])</script> is <script type="math/tex">4</script> at index <script type="math/tex">6</script>. 
</p>
</li>
<li id="a0000000111" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(b)
	</span>
<p>
: Swap with object at index <script type="math/tex">4</script>, giving <script type="math/tex">(1, 2, 2, 4, 7, 6)</script>. 
</p>
</li>
</ol>
</li>
<li id="a0000000112" value="5">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		5.
	</span>
<ol class="enumerate" id="a0000000113" style="list-style: none">
<li id="a0000000114" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(a)
	</span>
<p>
: Smallest object in <script type="math/tex">(1, 2, 2, 4, [7, 6])</script> is <script type="math/tex">6</script> at index <script type="math/tex">6</script>. 
</p>
</li>
<li id="a0000000115" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(b)
	</span>
<p>
: Swap with object at index <script type="math/tex">5</script>, giving <script type="math/tex">(1, 2, 2, 4, 6, 7)</script>. 
</p>
</li>
</ol>
</li>
<li id="a0000000116" value="6">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		6.
	</span>
<p>
We have reached the last object, so the list is sorted. 
</p>
</li>
</ol>
</section><section class="subsection">
<h3 id="a0000000117">3.3.3 Insertion sort</h3>
<p>
Conceptually this process splits the list <script type="math/tex">a</script> into two pieces, or sublists. One is sorted and the other unsorted. We write <script type="math/tex">a = (s | u)</script> where <script type="math/tex">|</script> marks the separation between the sublists. At the start <script type="math/tex">s</script> is empty and <script type="math/tex">u = a</script>. Then, while <script type="math/tex">u</script> is not empty, we 
</p>
<ol class="enumerate" id="a0000000118" style="list-style: none">
<li id="a0000000119" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
Compare the first entry of the unsorted list <script type="math/tex">u</script> with each entry of the sorted list <script type="math/tex">s</script> in turn <em>from the right</em>. 
</p>
</li>
<li id="a0000000120" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
If <script type="math/tex">u_1 < s_ i</script>, swap the entry in the sorted list with the first entry in the unsorted list. Do this for each entry in the sorted list until <script type="math/tex">u_1</script> is in order. 
</p>
</li>
<li id="a0000000121" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		3.
	</span>
<p>
Move the separation marker one entry to the right (so that <script type="math/tex">s_ i</script>, which was swapped with <script type="math/tex">u_1</script>, is still in the sorted list). 
</p>
</li>
</ol>
<p>
As with selection sort, when implemented in code we have two loops, one running over the whole list and one over some part of the list. We may expect the computational cost of the two to be similar. 
</p>
<p>
The steps for <script type="math/tex">a = (7, 2, 2, 6, 1, 4)</script> are as follows. 
</p>
<ol class="enumerate" id="a0000000122" style="list-style: none">
<li id="a0000000123" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<ol class="enumerate" id="a0000000124" style="list-style: none">
<li id="a0000000125" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(a)
	</span>
<p>
<script type="math/tex">(|7, 2, 2, 6, 1, 4)</script> has nothing in the unsorted list. 
</p>
</li>
<li id="a0000000126" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(b)
	</span>
<p>
Move the separation marker to the right, giving <script type="math/tex">(7 | 2, 2, 6, 1, 4)</script>. 
</p>
</li>
</ol>
</li>
<li id="a0000000127" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<ol class="enumerate" id="a0000000128" style="list-style: none">
<li id="a0000000129" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(a)
	</span>
<p>
As <script type="math/tex">2 < 7</script>, swap <script type="math/tex">s_1</script> and <script type="math/tex">u_1</script>, giving <script type="math/tex">(2 | 7, 2, 6, 1, 4)</script>. 
</p>
</li>
<li id="a0000000130" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(b)
	</span>
<p>
Move the separation marker to the right, giving <script type="math/tex">(2, 7 | 2, 6, 1, 4)</script>. 
</p>
</li>
</ol>
</li>
<li id="a0000000131" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		3.
	</span>
<ol class="enumerate" id="a0000000132" style="list-style: none">
<li id="a0000000133" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(a)
	</span>
<p>
As <script type="math/tex">2 < 7</script>, swap <script type="math/tex">s_2</script> and <script type="math/tex">u_1</script>, giving <script type="math/tex">(2, 2 | 7, 6, 1, 4)</script>. 
</p>
</li>
<li id="a0000000134" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(b)
	</span>
<p>
As <script type="math/tex">2</script> is not less than <script type="math/tex">2</script> no further sorting is needed. 
</p>
</li>
<li id="a0000000135" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(c)
	</span>
<p>
Move the separation marker to the right, giving <script type="math/tex">(2, 2, 7 | 6, 1, 4)</script>. 
</p>
</li>
</ol>
</li>
<li id="a0000000136" value="4">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		4.
	</span>
<ol class="enumerate" id="a0000000137" style="list-style: none">
<li id="a0000000138" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(a)
	</span>
<p>
As <script type="math/tex">6 < 7</script>, swap <script type="math/tex">s_3</script> and <script type="math/tex">u_1</script>, giving <script type="math/tex">(2, 2, 6 | 7, 1, 4)</script>. 
</p>
</li>
<li id="a0000000139" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(b)
	</span>
<p>
As <script type="math/tex">6</script> is not less than <script type="math/tex">2</script> no further sorting is needed. 
</p>
</li>
<li id="a0000000140" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(c)
	</span>
<p>
Move the separation marker to the right, giving <script type="math/tex">(2, 2, 6, 7 | 1, 4)</script>. 
</p>
</li>
</ol>
</li>
<li id="a0000000141" value="5">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		5.
	</span>
<ol class="enumerate" id="a0000000142" style="list-style: none">
<li id="a0000000143" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(a)
	</span>
<p>
As <script type="math/tex">1 < 7</script>, swap <script type="math/tex">s_4</script> and <script type="math/tex">u_1</script>, giving <script type="math/tex">(2, 2, 6, 1 | 7, 4)</script>. 
</p>
</li>
<li id="a0000000144" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(b)
	</span>
<p>
As <script type="math/tex">1 < 6</script>, swap <script type="math/tex">s_3</script> and (what was) <script type="math/tex">u_1</script>, giving <script type="math/tex">(2, 2, 1, 6 | 7, 4)</script>. 
</p>
</li>
<li id="a0000000145" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(c)
	</span>
<p>
As <script type="math/tex">1 < 2</script>, swap <script type="math/tex">s_2</script> and (what was) <script type="math/tex">u_1</script>, giving <script type="math/tex">(2, 1, 2, 6 | 7, 4)</script>. 
</p>
</li>
<li id="a0000000146" value="4">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(d)
	</span>
<p>
As <script type="math/tex">1 < 2</script>, swap <script type="math/tex">s_1</script> and (what was) <script type="math/tex">u_1</script>, giving <script type="math/tex">(1, 2, 2, 6 | 7, 4)</script>. 
</p>
</li>
<li id="a0000000147" value="5">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(e)
	</span>
<p>
Move the separation marker to the right, giving <script type="math/tex">(1, 2, 2, 6, 7 | 4)</script>. 
</p>
</li>
</ol>
</li>
<li id="a0000000148" value="6">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		6.
	</span>
<ol class="enumerate" id="a0000000149" style="list-style: none">
<li id="a0000000150" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(a)
	</span>
<p>
As <script type="math/tex">4 < 7</script>, swap <script type="math/tex">s_5</script> and <script type="math/tex">u_1</script>, giving <script type="math/tex">(1, 2, 2, 6, 4 | 7)</script>. 
</p>
</li>
<li id="a0000000151" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(b)
	</span>
<p>
As <script type="math/tex">4 < 6</script>, swap <script type="math/tex">s_4</script> and (what was) <script type="math/tex">u_1</script>, giving <script type="math/tex">(1, 2, 2, 4, 6 | 7)</script>. 
</p>
</li>
<li id="a0000000152" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(c)
	</span>
<p>
As <script type="math/tex">4</script> is not less than <script type="math/tex">2</script> no further sorting is needed. 
</p>
</li>
<li id="a0000000153" value="4">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(d)
	</span>
<p>
Move the separation marker to the right, giving <script type="math/tex">(1, 2, 2, 4, 6, 7 |)</script>. 
</p>
</li>
</ol>
</li>
<li id="a0000000154" value="7">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		7.
	</span>
<p>
The unsorted list is empty, so the sorted list is complete. 
</p>
</li>
</ol>
</section>
</section><section class="section">
<h2 id="a0000000155">3.4 Analysis of algorithms</h2>
<p>
We have three different algorithms to sort a list, and a rough idea of how they will behave. However, that rough idea could easily be wrong. If the first permutation generated by the brute-force method sorts the list then it is faster than either selection or insertion sort. 
</p>
<p>
Equally, it is generally impractical to work out how long a sorting algorithm may take in all cases and describe the result statistically, as the time taken will diverge to infinity with the size of the list. 
</p>
<p>
Instead, we will look at the <em>worst case</em>: what is the maximum length of time an algorithm may take? 
</p>
<section class="subsection">
<h3 id="a0000000156">3.4.1 Definitions</h3>
<p>
An <em>elementary operation</em> (EO) is any simple operation an algorithm may take with roughly the same cost. Examples would be comparisons, swaps, additions, multiplications, or assigning a value to a variable. 
</p>
<p>
The <em>instance size</em> is a number <script type="math/tex">n</script> that characterises the size of the problem. When sorting it would be the length of the list <script type="math/tex">a</script>. 
</p>
<p>
In the <em>worst case</em> analysis we reduce every choice that the algorithm makes to the one needing the most elementary operations. 
</p>
<section class="subsubsection">
<h4 id="a0000000157">Useful results</h4>
<p>
The <em>Gauss series</em> or arithmetic progression formula is 
</p>
<div class="eqn" id="a0000000158">
<script type="math/tex; mode=display">\begin{equation}1 + 2 + \dots + n = \sum _{i=1}^ n i = \frac{n (n+1)}{2}.\tag{3.3}\end{equation}</script>
</div>
<p>
The size of a set of consecutive integers, <script type="math/tex">\{  i, i+1, \dots , j \} </script> is 
</p>
<div class="eqn" id="a0000000159">
<script type="math/tex; mode=display">\begin{equation}| \{  i, i+1, \dots , j \}  | = j - i + 1.\tag{3.4}\end{equation}</script>
</div>
</section>
</section><section class="subsection">
<h3 id="a0000000160">3.4.2 Selection Sort</h3>
<div class="highlight"><pre><span></span><span class="linenos">1</span>for i in range(0, n-1):
<span class="linenos">2</span>    j = i
<span class="linenos">3</span>    for k in range(i+1, n):
<span class="linenos">4</span>        if a[k] &lt; a[j]:
<span class="linenos">5</span>            j = k
<span class="linenos">6</span>    if a[j] &lt; a[i]:
<span class="linenos">7</span>        a[i], a[j] = a[j], a[i]
</pre></div>
<p>
This Python code performs selection sort. 
</p>
<ul class="itemize" id="a0000000161">
<li id="a0000000162"> <p>
Line 1 loops <script type="math/tex">n-1</script> times over: 
</p>
<ul class="itemize" id="a0000000163">
<li id="a0000000164"> <p>
Line 2 assigns one value (1 EO); 
</p>
</li>
<li id="a0000000165"> <p>
Line 3 loops <script type="math/tex">n - (i+1) + 1</script> times over: 
</p>
<ul class="itemize" id="a0000000166">
<li id="a0000000167"> <p>
Line 4 does one comparison (1 EO); 
</p>
</li>
<li id="a0000000168"> <p>
Line 5 assigns one value (1 EO); 
</p>
</li>
</ul>
<p>
 The total cost of the loop is <script type="math/tex">2 (n - i)</script> EOs; 
</p>
</li>
<li id="a0000000169"> <p>
Line 6 does one comparison (1 EO); 
</p>
</li>
<li id="a0000000170"> <p>
Line 7 does one comparison (1 EO); 
</p>
</li>
</ul>
<p>
 The total cost of the loop is 
</p>
<div id="a0000000171">
<div class="eqnarrayid" id="a0000000172"></div><div class="eqnarrayid" id="a0000000173"></div><div class="eqnarrayid" id="a0000000174"></div><script type="math/tex; mode=display">
\begin{align}
\tag{3.5} \sum _{i=1}^{n-1} (1 + 2(n - i) + 2) & = \sum _{i=1}^{n-1} (2 n + 3) - 2 \sum _{i-1}^{n-1} i \\ 
\tag{3.6}& = (n-1)(2n+3) - 2 \frac{(n-1) n}{2} \\ 
\tag{3.7}& = (n-1)(n+3) = n^2 + 2 n - 3. 
\end{align}
</script>
</div>
</li>
</ul>
<p>
We see that the analysis gives the worst case of selection sort as <script type="math/tex">\sim n^2</script>. As shown earlier this grows much more slowly that the worst case <script type="math/tex">\sim n^ n</script> for the brute-force algorithm. Selection sort may be practical. 
</p>
</section><section class="subsection">
<h3 id="a0000000175">3.4.3 Insertion Sort</h3>
<div class="highlight"><pre><span></span><span class="linenos">1</span>for i in range(1, n):
<span class="linenos">2</span>    for j in range(i, 0, -1):
<span class="linenos">3</span>        if a[j] &lt; a[j-1]:
<span class="linenos">4</span>            a[i], a[j] = a[j], a[i]
<span class="linenos">5</span>        else:
<span class="linenos">6</span>            break
</pre></div>
<p>
This Python code performs insertion sort. 
</p>
<ul class="itemize" id="a0000000176">
<li id="a0000000177"> <p>
Line 1 loops <script type="math/tex">n-1</script> times over: 
</p>
<ul class="itemize" id="a0000000178">
<li id="a0000000179"> <p>
Line 2 loops <script type="math/tex">i</script> times over: 
</p>
<ul class="itemize" id="a0000000180">
<li id="a0000000181"> <p>
Line 3 does one comparison (1 EO); 
</p>
</li>
<li id="a0000000182"> <p>
Line 4 does one swap (1 EO); 
</p>
</li>
<li id="a0000000183"> <p>
Lines 5 and 6 never occur in the worst case. 
</p>
</li>
</ul>
<p>
 The total cost of the loop is <script type="math/tex">2 (i - i)</script> EOs; 
</p>
</li>
</ul>
<p>
 The total cost of the loop is 
</p>
<div id="a0000000184">
<div class="eqnarrayid" id="a0000000185"></div><div class="eqnarrayid" id="a0000000186"></div><div class="eqnarrayid" id="a0000000187"></div><div class="eqnarrayid" id="a0000000188"></div><script type="math/tex; mode=display">
\begin{align}
\tag{3.8} \sum _{i=2}^{n} 2 (i - 1) & = \sum _{i=1}^{n} 2 (i - 1) \\ 
\tag{3.9}& = 2 \sum _{i=1}^ n i - 2 \sum _{i=1}^ n 1 \\ 
\tag{3.10}& = \frac{n (n+1)}{2} - 2 n \\ 
\tag{3.11}& = n^2 - n. 
\end{align}
</script>
</div>
</li>
</ul>
<p>
We see that the analysis gives the worst case of insertion sort as <script type="math/tex">\sim n^2</script>. For large <script type="math/tex">n</script> we expect insertion sort to be slightly faster than selection sort. 
</p>
</section>
</section><section class="section">
<h2 id="a0000000189">3.5 Computational complexity</h2>
<p>
In general, comparing algorithms by computing the number of elementary operations explicitly can be painfully hard to do. Also, it is often not useful. What we care about is how the cost (the number of elementary operations) grows as the instance size <script type="math/tex">n</script> grows. We therefore only care about the <em>largest</em> term in the <em>worst case</em> as <script type="math/tex">n \to \infty </script>. 
</p>
<section class="subsection">
<h3 id="a0000000190">3.5.1 Big <script type="math/tex">\mathcal{O}</script> notation</h3>
<p>
Given two functions <script type="math/tex">f, g \colon \mathbb {R} \to \mathbb {R}</script>, we say that <script type="math/tex">f = \mathcal{O}(g)</script>, or <script type="math/tex">f</script> is of the same order as <script type="math/tex">g</script>, if <script type="math/tex">\exists n_0, c \in \mathbb {R}^+ \setminus \{ 0\} </script> such that 
</p>
<div class="eqn" id="a0000000191">
<script type="math/tex; mode=display">\begin{equation}f(n) \le c g(n) \quad \forall n \ge n_0.\tag{3.12}\end{equation}</script>
</div>
<p>
 In other words, for large enough values <script type="math/tex">f</script> can be bounded by scaling <script type="math/tex">g</script> by a constant. This is illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:complexity:big_O">3.1</a>. 
</p>
<figure id="fig:complexity:big_O">
<p>
<img alt="The function f is of the same order as the function g if it can be bounded by some constant multiple of g for all positive real numbers." src="../../notes/course_notes/images/img-0030.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">3.1</span>
<span class="caption_text">The function <script type="math/tex">f</script> is of the same order as the function <script type="math/tex">g</script> if it can be bounded by some constant multiple of <script type="math/tex">g</script> for all positive real numbers.</span>
</figcaption>
</figure>
<p>
The purpose of computational complexity analysis is to bound any function <script type="math/tex">f</script> in terms of a small, simple set of functions <script type="math/tex">g</script>. We want the functions to be simple to make the analysis easier. Equally, we want the specific function used to be as close as possible to <script type="math/tex">f</script>, so the bound does not over-estimate too much. 
</p>
</section><section class="subsection">
<h3 id="a0000000192">3.5.2 Computational complexity</h3>
<p>
Consider two algorithms <script type="math/tex">A</script> and <script type="math/tex">B</script> that solve the same problem <script type="math/tex">P</script>. Let <script type="math/tex">f_ A(n), f_ B(n)</script> be the number of elementary operations needed for each algorithm as a function of the instance size. Then <script type="math/tex">\mathcal{O}(f_ A)</script> is the <em>computational complexity</em> of algorithm <script type="math/tex">A</script> (similarly for algorithm <script type="math/tex">B</script>), and we consider <script type="math/tex">A</script> to be <em>more efficient</em> than <script type="math/tex">B</script> if 
</p>
<div class="eqn" id="a0000000193">
<script type="math/tex; mode=display">\begin{equation}\mathcal{O}(f_ A) < \mathcal{O}(f_ B)\tag{3.13}\end{equation}</script>
</div>
<p>
 asymptotically, in the limit as <script type="math/tex">n \to \infty </script>. 
</p>
<p>
Examples include 
</p>
<ul class="itemize" id="a0000000194">
<li id="a0000000195"> <p>
An <script type="math/tex">\mathcal{O}(\log n)</script> algorithm is more efficient than an <script type="math/tex">\mathcal{O}(n)</script> algorithm. 
</p>
</li>
<li id="a0000000196"> <p>
An <script type="math/tex">\mathcal{O}(n^2)</script> algorithm is more efficient than an <script type="math/tex">\mathcal{O}(n^3)</script> algorithm. 
</p>
</li>
<li id="a0000000197"> <p>
An <script type="math/tex">\mathcal{O}(n^ k)</script> algorithm is more efficient than an <script type="math/tex">\mathcal{O}(2^ n)</script> algorithm, if <script type="math/tex">k \in \mathbb {N}</script>. 
</p>
</li>
</ul>
<p>
There are two implicit assumptions we have to make about the functions <script type="math/tex">f(n)</script> to make progress. One is that the number of elementary operations is strictly non-negative so that <script type="math/tex">f \colon \mathbb {R}^+ \setminus \{  0 \} </script>. This seems natural. The other is that <script type="math/tex">f</script> is strictly increasing. This need not be true in general, but is usually a very good approximation. 
</p>
</section><section class="subsection">
<h3 id="a0000000198">3.5.3 Properties of the asymptotic model</h3>
<section class="subsubsection">
<h4 id="a0000000199">When functions are the same order</h4>
<p>
<div class="thmwrapper prop_thmwrapper" id="thm:complexity:limits">
<div class="thmheading prop_thmheading">
<span class="thmcaption prop_thmcaption">
    Property
    </span>
<span class="thmlabel prop_thmlabel">5.1</span>
</div>
<div class="thmcontent prop_thmcontent">
<p>
 Let <script type="math/tex">f, g \colon \mathbb {R}^+ \setminus \{  0 \}  \to \mathbb {R}^+ \setminus \{  0 \} </script>. If 
</p>
<div class="eqn" id="a0000000200">
<script type="math/tex; mode=display">\begin{equation}\lim _{n \to \infty } \frac{f(n)}{g(n)} = l \in (0, \infty )\tag{3.14}\end{equation}</script>
</div>
<p>
 then <script type="math/tex">f = \mathcal{O}(g)</script> and <script type="math/tex">g = \mathcal{O}(f)</script>. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000201">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
The definition of the limit implies <script type="math/tex">\exists \epsilon > 0, N > 0</script> such that 
</p>
<div class="eqn" id="a0000000202">
<script type="math/tex; mode=display">\begin{equation}\left| \frac{f(n)}{g(n)} - l \right| < \epsilon , \quad \forall n \ge N.\tag{3.15}\end{equation}</script>
</div>
<p>
 This is equivalent to 
</p>
<div class="eqn" id="a0000000203">
<script type="math/tex; mode=display">\begin{equation}l - \epsilon < \frac{f(n)}{g(n)} < l + \epsilon , \quad \forall n \ge N.\tag{3.16}\end{equation}</script>
</div>
<p>
 We now have two cases. 
</p>
<ol class="enumerate" id="a0000000204" style="list-style: none">
<li id="a0000000205" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
From the upper bound we have <script type="math/tex">f(n) < (l + \epsilon ) g(n)</script> for all <script type="math/tex">n \ge N</script>. By setting <script type="math/tex">n_0 = N</script> and <script type="math/tex">c = (l + \epsilon )</script>, the definition gives that <script type="math/tex">f = \mathcal{O}(g)</script>. 
</p>
</li>
<li id="a0000000206" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
From the lower bound we have (assuming, without loss of generality, that <script type="math/tex">\epsilon < l</script>) <script type="math/tex">g(n) < (l - \epsilon )^{-1} f(n)</script>. By setting <script type="math/tex">n_0 = N</script> and <script type="math/tex">c = (l - \epsilon )^{-1}</script>, the definition gives that <script type="math/tex">g = \mathcal{O}(f)</script>. 
</p>
</li>
</ol>
</div>
</div>
<p>
This shows that (non-zero!) constant factors are essentially irrelevant. 
</p>
</section><section class="subsubsection">
<h4 id="a0000000207">When one function is of lower order</h4>
<p>
<div class="thmwrapper prop_thmwrapper" id="a0000000208">
<div class="thmheading prop_thmheading">
<span class="thmcaption prop_thmcaption">
    Property
    </span>
<span class="thmlabel prop_thmlabel">5.2</span>
</div>
<div class="thmcontent prop_thmcontent">
<p>
Let <script type="math/tex">f, g \colon \mathbb {R}^+ \setminus \{  0 \}  \to \mathbb {R}^+ \setminus \{  0 \} </script>. If 
</p>
<div class="eqn" id="a0000000209">
<script type="math/tex; mode=display">\begin{equation}\lim _{n \to \infty } \frac{f(n)}{g(n)} = 0\tag{3.17}\end{equation}</script>
</div>
<p>
 then <script type="math/tex">f = \mathcal{O}(g)</script> but <script type="math/tex">g \ne \mathcal{O}(f)</script>. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000210">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
This is very similar to the previous proof. 
</p>
<p>
The definition of the limit implies <script type="math/tex">\exists \epsilon > 0, N > 0</script> such that 
</p>
<div class="eqn" id="a0000000211">
<script type="math/tex; mode=display">\begin{equation}\left| \frac{f(n)}{g(n)} - 0 \right| < \epsilon , \quad \forall n \ge N.\tag{3.18}\end{equation}</script>
</div>
<p>
 This is equivalent to 
</p>
<div class="eqn" id="a0000000212">
<script type="math/tex; mode=display">\begin{equation}- \epsilon < \frac{f(n)}{g(n)} < \epsilon , \quad \forall n \ge N.\tag{3.19}\end{equation}</script>
</div>
<p>
 We now have two cases. 
</p>
<ol class="enumerate" id="a0000000213" style="list-style: none">
<li id="a0000000214" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
From the upper bound we have <script type="math/tex">f(n) < \epsilon g(n)</script> for all <script type="math/tex">n \ge N</script>. By setting <script type="math/tex">n_0 = N</script> and <script type="math/tex">c = \epsilon </script>, the definition gives that <script type="math/tex">f = \mathcal{O}(g)</script>. 
</p>
</li>
<li id="a0000000215" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
By contradiction, assume <script type="math/tex">g = \mathcal{O}(f)</script>. By definition, there must exist <script type="math/tex">n_0, c \in \mathbb {R}^+ \setminus \{  0 \} </script> such that <script type="math/tex">g(n) \le c f(n)</script> for all <script type="math/tex">n \ge n_0</script>. Thus 
</p>
<div class="eqn" id="a0000000216">
<script type="math/tex; mode=display">\begin{equation}\frac{f(n)}{g(n)} \ge \frac{1}{c} > 0, \quad \forall n \ge n_0.\tag{3.20}\end{equation}</script>
</div>
<p>
 This contradicts the limit <script type="math/tex">\lim _{n\to \infty } \frac{f(n)}{g(n)} = 0</script>. Therefore <script type="math/tex">g \ne \mathcal{O}(f)</script>. 
</p>
</li>
</ol>
</div>
</div>
<p>
In this case we say that <script type="math/tex">f</script> is of <em>lower order</em> than <script type="math/tex">g</script>. 
</p>
</section><section class="subsubsection">
<h4 id="a0000000217">Constants are irrelevant</h4>
<p>
<div class="thmwrapper prop_thmwrapper" id="a0000000218">
<div class="thmheading prop_thmheading">
<span class="thmcaption prop_thmcaption">
    Property
    </span>
<span class="thmlabel prop_thmlabel">5.3</span>
</div>
<div class="thmcontent prop_thmcontent">
<p>
Assume <script type="math/tex">a, b \in \mathbb {R}^+ \setminus \{  0 \} </script>. Then 
</p>
<div class="eqn" id="a0000000219">
<script type="math/tex; mode=display">\begin{equation}a f(n) + b = \mathcal{O}(f(n))\tag{3.21}\end{equation}</script>
</div>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000220">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
This follows from theorem <a class="ref" href="../../notes/course_notes/index.html#thm:complexity:limits">5.1</a>, as 
</p>
<div class="eqn" id="a0000000221">
<script type="math/tex; mode=display">\begin{equation}\lim _{n\to \infty } \frac{a f(n) + b}{f(n)} = a \in (0, \infty ).\tag{3.22}\end{equation}</script>
</div>
</div>
</div>
</section><section class="subsubsection">
<h4 id="a0000000222">All logarithms are the same</h4>
<p>
<div class="thmwrapper prop_thmwrapper" id="a0000000223">
<div class="thmheading prop_thmheading">
<span class="thmcaption prop_thmcaption">
    Property
    </span>
<span class="thmlabel prop_thmlabel">5.4</span>
</div>
<div class="thmcontent prop_thmcontent">
<p>
Assume <script type="math/tex">a, b \in \mathbb {R}^+ \setminus \{  0 \} </script>. Then 
</p>
<div class="eqn" id="a0000000224">
<script type="math/tex; mode=display">\begin{equation}\log _ a n = \mathcal{O} \left( \log _ b n \right).\tag{3.23}\end{equation}</script>
</div>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000225">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
This follows from the previous case, as 
</p>
<div class="eqn" id="a0000000226">
<script type="math/tex; mode=display">\begin{equation}\log _ a n = (\frac{1}{\log _ b a}) \log _ b n\tag{3.24}\end{equation}</script>
</div>
<p>
 and the term in brackets is a constant. 
</p>
</div>
</div>
</section><section class="subsubsection">
<h4 id="a0000000227">Lower order terms are irrelevant</h4>
<p>
<div class="thmwrapper prop_thmwrapper" id="a0000000228">
<div class="thmheading prop_thmheading">
<span class="thmcaption prop_thmcaption">
    Property
    </span>
<span class="thmlabel prop_thmlabel">5.5</span>
</div>
<div class="thmcontent prop_thmcontent">
<p>
If <script type="math/tex">g</script> is of lower order than <script type="math/tex">f</script> then 
</p>
<div class="eqn" id="a0000000229">
<script type="math/tex; mode=display">\begin{equation}f(n) + g(n) = \mathcal{O}(f).\tag{3.25}\end{equation}</script>
</div>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000230">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<div id="a0000000231">
<div class="eqnarrayid" id="a0000000232"></div><div class="eqnarrayid" id="a0000000233"></div><script type="math/tex; mode=display">
\begin{align}
\tag{3.26} \lim _{n\to \infty } \frac{f(n) + g(n)}{f(n)} & = \lim _{n\to \infty } \left( 1 + \frac{g(n)}{f(n)} \right) \\ 
\tag{3.27}& = 1. 
\end{align}
</script>
</div>
<p>
 Hence theorem <a class="ref" href="../../notes/course_notes/index.html#thm:complexity:limits">5.1</a> gives the result. 
</p>
</div>
</div>
</section><section class="subsubsection">
<h4 id="a0000000234">Shifts are irrelevant</h4>
<p>
<div class="thmwrapper prop_thmwrapper" id="a0000000235">
<div class="thmheading prop_thmheading">
<span class="thmcaption prop_thmcaption">
    Property
    </span>
<span class="thmlabel prop_thmlabel">5.6</span>
</div>
<div class="thmcontent prop_thmcontent">
<p>
For a monotone increasing function <script type="math/tex">f</script>, 
</p>
<div class="eqn" id="a0000000236">
<script type="math/tex; mode=display">\begin{equation}f(n + a) = \mathcal{O}(f).\tag{3.28}\end{equation}</script>
</div>
</div>
</div>
</p>
</section><section class="subsubsection">
<h4 id="a0000000237">Rounding operators are irrelevant</h4>
<p>
<div class="thmwrapper prop_thmwrapper" id="a0000000238">
<div class="thmheading prop_thmheading">
<span class="thmcaption prop_thmcaption">
    Property
    </span>
<span class="thmlabel prop_thmlabel">5.7</span>
</div>
<div class="thmcontent prop_thmcontent">
<p>
The ceiling operator <script type="math/tex">\lceil n \rceil </script> returns the smallest integer greater than <script type="math/tex">n</script>. We have 
</p>
<div class="eqn" id="a0000000239">
<script type="math/tex; mode=display">\begin{equation}\lceil f(n) \rceil = \mathcal{O}(f).\tag{3.29}\end{equation}</script>
</div>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000240">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
This follows from 
</p>
<div class="eqn" id="a0000000241">
<script type="math/tex; mode=display">\begin{equation}\lceil f(n) \rceil \le f(n) + 1 = \mathcal{O}(f).\tag{3.30}\end{equation}</script>
</div>
</div>
</div>
</section>
</section>
</section><section class="section">
<h2 id="a0000000242">3.6 Cobham-Edmonds thesis</h2>
<p>
A suggestion from 1965 by Alan Cobham and Jack Edmonds is that a problem <script type="math/tex">P</script> is <em>tractable</em> if 
</p>
<ol class="enumerate" id="a0000000243" style="list-style: none">
<li id="a0000000244" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
there is an algorithm <script type="math/tex">A</script> that solves <script type="math/tex">P</script>; 
</p>
</li>
<li id="a0000000245" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
<script type="math/tex">A</script> has computational complexity at most polynomial in the size of instances of <script type="math/tex">P</script>. 
</p>
</li>
</ol>
<p>
 Generally we think of tractable problems as solvable on a computer, whilst problems that are not tractable are not. In many specific cases this is untrue, as “average” instances of problems may be solved by the algorithm <script type="math/tex">A</script> much faster than the worst case suggests. 
</p>
<p>
This chapter has shown that the sorting problem is tractable, by constructing two algorithms (selection and insertion sort) that are <script type="math/tex">\mathcal{O}(n^2)</script>. Neither are the fastest sorting algorithm available. It is important to note that the existence of a slower algorithm (such as brute-force sort, with complexity <script type="math/tex">\mathcal{O}(n!)</script>) does not mean that the <em>problem</em> in intractable.  
</p>
</section><!-- Latex Chapter/Part -->
<h1 id="chap:simplex">The Simplex Method</h1>
<section class="section">
<h2 id="a0000000246">4.1 Recap</h2>
<p>
In the previous chapters we introduced the linear programming problem. We saw how this could be solved (graphically) for two variables, and also constructed an impractical, brute-force method that would work (very slowly) for the general case. 
</p>
<p>
Problems of current interest can have thousands of constraints and millions of variables. To solve these we want to introduce and analyse the <em>simplex method</em>. Introduced by Dantzig in 1947, it builds on the fundamental theorem by giving a method of moving, step by step, from one vertex to an adjacent one until the optimal solution is found. 
</p>
<p>
There are a number of steps we need to complete. 
</p>
<ol class="enumerate" id="a0000000247" style="list-style: none">
<li id="a0000000248" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
How do we characterise a vertex (algebraically)? 
</p>
</li>
<li id="a0000000249" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
How do we find a vertex to start from? 
</p>
</li>
<li id="a0000000250" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		3.
	</span>
<p>
How do we verify if the current vertex is optimal? 
</p>
</li>
<li id="a0000000251" value="4">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		4.
	</span>
<p>
How do we move from one vertex to the next? 
</p>
</li>
</ol>
</section><section class="section">
<h2 id="a0000000252">4.2 Setup and assumptions</h2>
<p>
In this chapter we will use the standard matrix form, 
</p>
<div class="eqn" id="eq:simplex:std-form">
<script type="math/tex; mode=display">\begin{equation}\label{eq:simplex:std-form} \begin{array}{l@{\quad }rcl} \min &  c x & & \\ \text{subject to} &  A x &  = &  b \\ &  x &  \ge &  0. \end{array}\tag{4.1}\end{equation}</script>
</div>
<p>
 Here <script type="math/tex">A \in \mathbb {R}^{m \times n}, c, x \in \mathbb {R}^ n, b \in \mathbb {R}^ m</script> are the given coefficients that define the problem. As usual <script type="math/tex">m</script> is the number of constraints and <script type="math/tex">n</script> the number of variables. 
</p>
<p>
We make three assumptions: 
</p>
<ol class="enumerate" id="a0000000253" style="list-style: none">
<li id="a0000000254" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
<script type="math/tex">b \ge 0</script>. If this is not true for some row <script type="math/tex">i</script> so that <script type="math/tex">b_ i < 0</script> we can multiply that row (both <script type="math/tex">b_ i</script> and <script type="math/tex">A_{ij}</script> for all columns <script type="math/tex">j</script>) by <script type="math/tex">-1</script>. 
</p>
</li>
<li id="a0000000255" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
<script type="math/tex">m < n</script>. That is, the number of constraints is less than the number of variables. If this is not true then the linear system defined by <script type="math/tex">A x = b</script> is either square or overdetermined, implying one or no solutions (the feasible region is a single point or empty). 
</p>
</li>
<li id="a0000000256" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		3.
	</span>
<p>
<script type="math/tex">A</script> has full row rank so its rows are linearly independent. 
</p>
</li>
</ol>
<p>
The second assumption may seem to contradict earlier examples where there were more constraints than variables. However, in all those cases the constraints were <em>inequalities</em>. To transform to standard form we need to increase the number of variables (using slack or surplus variables). This will change all those problems to ones with <script type="math/tex">m < n</script>. 
</p>
<p>
The use of the third assumption can be checked by assuming <script type="math/tex">A</script> is not of full row rank. In that case we can use row operations to transform the system to <script type="math/tex">A' x = b'</script>, where the matrix <script type="math/tex">A'</script> contains two rows <script type="math/tex">i</script> and <script type="math/tex">k</script> such that 
</p>
<div id="a0000000257">
<div class="eqnarrayid" id="a0000000258"></div><div class="eqnarrayid" id="a0000000259"></div><div class="eqnarrayid" id="a0000000260"></div><script type="math/tex; mode=display">
\begin{align}
\tag{4.2} a’_ i x & = b’_ i, \\ 
\tag{4.3}a’_ k x & = b’_ k, \\ 
\tag{4.4}a’_ i & = a’_ k. 
\end{align}
</script>
</div>
<p>
 There are then two cases. 
</p>
<ol class="enumerate" id="a0000000261" style="list-style: none">
<li id="a0000000262" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
<script type="math/tex">b'_ i = b'_ k</script>: the two constraints are identical and one can be dropped from the problem. 
</p>
</li>
<li id="a0000000263" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
<script type="math/tex">b'_ i \ne b'_ k</script>: the constraints are inconsistent and so the linear problem is infeasible. 
</p>
</li>
</ol>
<p>
 So the third assumption stops us from considering infeasible problems and ensures constraints are not repeating information. 
</p>
</section><section class="section">
<h2 id="a0000000264">4.3 Basic matrices</h2>
<p>
There is a general mathematical strategy of solving a complex problem by first solving a simple case, then transforming the general case to the simple one. This can seem indirect. The next few sections will build up a simple case for linear programs. 
</p>
<p>
Let <script type="math/tex">B \subseteq \{  1, \dots , n \} </script> be a subset of the column indexes of <script type="math/tex">A</script>, with <script type="math/tex">|B| = m</script>. That is, <script type="math/tex">B</script> will identify a number of columns of <script type="math/tex">A</script>, corresponding to variables in the linear program, and the number of columns identified will match the number of constraints. 
</p>
<p>
A <em>basic matrix</em> <script type="math/tex">A_ B</script> is the submatrix of <script type="math/tex">A</script> with <em>linearly independent columns</em> that is obtained by dropping every column with index not in <script type="math/tex">B</script>. If <script type="math/tex">A_ B</script> is a basic matrix then 
</p>
<ul class="itemize" id="a0000000265">
<li id="a0000000266"> <p>
<script type="math/tex">A_ B</script> is square; 
</p>
</li>
<li id="a0000000267"> <p>
<script type="math/tex">A_ B</script> has full row and column rank (by the assumptions); 
</p>
</li>
<li id="a0000000268"> <p>
<script type="math/tex">A_ B</script> is invertible, as it has full row and column rank. 
</p>
</li>
</ul>
<p>
We can use this construction to split, of <em>partition</em>, the linear program. Let <script type="math/tex">N = \{ 1, \dots , n\}  \setminus B</script> be the complement of <script type="math/tex">B</script>. Let <script type="math/tex">c_ B, x_ B, A_ B</script> be the components (for the vectors <script type="math/tex">c, x</script>) or columns (for the matrix <script type="math/tex">A</script>) that are indexed by <script type="math/tex">B</script>, and <script type="math/tex">c_ N, x_ N, A_ N</script> be the components (for the vectors <script type="math/tex">c, x</script>) or columns (for the matrix <script type="math/tex">A</script>) that are indexed by <script type="math/tex">N</script>. Then we can use column operations on the linear program to re-order the vectors and matrices, writing 
</p>
<div id="a0000000269">
<div class="eqnarrayid" id="a0000000270"></div><div class="eqnarrayid" id="a0000000271"></div><div class="eqnarrayid" id="a0000000272"></div><script type="math/tex; mode=display">
\begin{align}
\tag{4.5} c & = (c_ B, c_ N), \\ 
\tag{4.6}A & = (A_ B, A_ N), \\ 
\tag{4.7}x & = (x_ B, x_ N). 
\end{align}
</script>
</div>
<p>
This means that our standard matrix form description of the linear program becomes 
</p>
<div class="eqn" id="a0000000273">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl} \min & \begin{pmatrix}  c_ B 

&  c_ N 

\end{pmatrix}\begin{pmatrix}  x_ B 

\\ x_ N 

\end{pmatrix}& & \\ \text{subject to} & \begin{pmatrix}  A_ B 

&  A_ N 

\end{pmatrix}\begin{pmatrix}  x_ B 

\\ x_ N 

\end{pmatrix}&  = &  b \\ & \begin{pmatrix}  x_ B 

\\ x_ N 

\end{pmatrix}&  \ge & \begin{pmatrix}  0 

\\ 0 

\end{pmatrix}. \end{array}\tag{4.8}\end{equation}</script>
</div>
<p>
 Rewriting this by expanding out the matrix multiplications gives 
</p>
<div class="eqn" id="a0000000274">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl} \min &  c_ B x_ B + c_ N x_ N & & \\ \text{subject to} &  A_ B x_ B + A_ N x_ N &  = &  b \\ &  x_ B &  \ge &  0 \\ &  x_ N &  \ge &  0. \end{array}\tag{4.9}\end{equation}</script>
</div>
<p>
Why have we made the problem more complicated? Because the basic matrix is invertible, we can <em>directly solve</em> for the optimal basic solution. We have 
</p>
<div id="a0000000275">
<div class="eqnarrayid" id="a0000000276"></div><div class="eqnarrayid" id="a0000000277"></div><div class="eqnarrayid" id="a0000000278"></div><script type="math/tex; mode=display">
\begin{align}
\tag{4.10}& &  A x & = b \\ 
\tag{4.11}\iff & &  A_ B x_ B + A_ N x_ N & = b \\ 
\tag{4.12}\iff & &  x_ B & = A_ B^{-1} b - A_ B^{-1} A_ N x_ N. 
\end{align}
</script>
</div>
<p>
 This allows us to write the objective function as 
</p>
<div id="a0000000279">
<div class="eqnarrayid" id="a0000000280"></div><div class="eqnarrayid" id="a0000000281"></div><script type="math/tex; mode=display">
\begin{align}
\tag{4.13} c x & = c_ B x_ B + c_ N x_ N \\ 
\tag{4.14}& = c_ B A_ B^{-1} b + \left( c_ N - c_ B A_ B^{-1} A_ N \right) x_ N. 
\end{align}
</script>
</div>
<p>
 We can also add the term <script type="math/tex">(c_ B - c_ B A_ B^{-1} A_ B ) x_ B</script> to the objective function as it vanishes. This is useful later. 
</p>
<p>
This defines the <em>basic form</em> of a standard form linear program: if <script type="math/tex">A_ B</script> is a basic matrix then the basic form is 
</p>
<div class="eqn" id="eq:simplex:basic-form">
<script type="math/tex; mode=display">\begin{equation}\label{eq:simplex:basic-form} \begin{array}{l@{\quad }rcl} \min &  c_ B A_ B^{-1} b + \left( c_ N - c_ B A_ B^{-1} A_ N \right) x_ N & +&  \left( c_ B - c_ B A_ B^{-1} A_ B \right) x_ B \\ \text{subject to} &  x_ B + A_ B^{-1} A_ N x_ N &  = &  A_ B^{-1} b \\ &  x_ B &  \ge &  0 \\ &  x_ N &  \ge &  0. \end{array}\tag{4.15}\end{equation}</script>
</div>
</section><section class="section">
<h2 id="a0000000282">4.4 Basic solutions</h2>
<p>
When the linear program is in basic form we call <script type="math/tex">x_ B</script> the <em>basic variables</em> and <script type="math/tex">x_ N</script> the <em>non-basic variables</em>. If there is a solution with <script type="math/tex">x_ N = 0</script> we call it a <em>basic solution</em>. A basic solution need not satisfy <script type="math/tex">x_ B \ge 0</script> and so it may not fall in the feasible region. If there is a solution <script type="math/tex">x = (x_ B, x_ N)</script> with <script type="math/tex">x_ N = 0</script> and also <script type="math/tex">x_ B \ge 0</script> then it is called <em>basic feasible</em>. 
</p>
<p>
Note that the constraints automatically imply that if the solution is basic and so <script type="math/tex">x_ N = 0</script>, then 
</p>
<div class="eqn" id="a0000000283">
<script type="math/tex; mode=display">\begin{equation}x_ B = A_ B^{-1} b.\tag{4.16}\end{equation}</script>
</div>
<p>
 Basic solutions can be constructed by solving the linear system defined by the basic matrix. 
</p>
<section class="subsection">
<h3 id="a0000000284">4.4.1 Basic solutions and vertices</h3>
<p>
There is a direct link between basic solutions and vertices. 
</p>
<p>
<div class="thmwrapper thm_thmwrapper" id="a0000000285">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">4.1</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
<script type="math/tex">x</script> is a basic feasible solution if, and only if, it is a vertex of the feasible region. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000286">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
First prove the implication using contradiction. 
</p>
<p>
Let <script type="math/tex">x</script> be a basic feasible solution with <script type="math/tex">x = (x_ B, x_ N)</script>. Assume, by contradiction, that <script type="math/tex">x</script> is not a vertex. As the feasible region is convex, if <script type="math/tex">x</script> is not a vertex then there are two distinct points <script type="math/tex">y, z</script>, both distinct from <script type="math/tex">x</script>, such that 
</p>
<div class="eqn" id="a0000000287">
<script type="math/tex; mode=display">\begin{equation}x = \lambda y + (1 - \lambda ) z, \quad \lambda \in (0, 1).\tag{4.17}\end{equation}</script>
</div>
<p>
 We can split both points in the same way as the basic feasible solution <script type="math/tex">x</script>, as <script type="math/tex">y = (y_ B, y_ N)</script> and <script type="math/tex">z = (z_ B, z_ N)</script>. This gives 
</p>
<div class="eqn" id="a0000000288">
<script type="math/tex; mode=display">\begin{equation}x_ N = \lambda y_ N + (1 - \lambda ) z_ N, \quad \lambda \in (0, 1).\tag{4.18}\end{equation}</script>
</div>
<p>
 As <script type="math/tex">x</script> is a basic feasible solution we have <script type="math/tex">x_ N = 0</script>. As <script type="math/tex">\lambda \in (0, 1)</script> we have <script type="math/tex">\lambda > 0</script> and <script type="math/tex">1 - \lambda > 0</script>. As <script type="math/tex">y</script> and <script type="math/tex">z</script> are feasible we have <script type="math/tex">y_ N, z_ N \ge 0</script>. This requires that <script type="math/tex">y_ N = 0 = z_ N</script>. 
</p>
<p>
Similarly, as <script type="math/tex">y</script> and <script type="math/tex">z</script> are feasible, we also have that <script type="math/tex">A y = b</script> and <script type="math/tex">A z = b</script>. As all the non-basic pieces must vanish, we have that <script type="math/tex">A_ B x_ B = b = A_ B y_ B = A_ B z_ B</script>. Since <script type="math/tex">A_ B</script> is non-singular (as it is a basic matrix), any linear system defined by it has a unique solution. Therefore <script type="math/tex">x_ B = y_ B = z_ B</script>. As all the non-basic pieces vanish, we have that <script type="math/tex">x = y = z</script>. This contradicts the assumption that they are all distinct. Therefore a basic feasible solution is a vertex. 
</p>
<p>
Next prove that a vertex is a basic feasible solution. Define <script type="math/tex">\hat{B} \subseteq \{ 1, \dots , n \} </script> as the set of indexes of the components of the vertex <script type="math/tex">x</script> which are positive, <script type="math/tex">\hat{B} = \{  i \colon x_ i > 0 \} </script>. Let <script type="math/tex">\hat{N}</script> be the complement, <script type="math/tex">\hat{N} = \{ 1, \dots , n \}  \setminus \hat{B}</script>. Write <script type="math/tex">x = (x_{\hat{B}}, x_{\hat{N}})</script> and re-write <script type="math/tex">A x = b</script> as 
</p>
<div class="eqn" id="a0000000289">
<script type="math/tex; mode=display">\begin{equation}A_{\hat{B}} x_{\hat{B}} + A_{\hat{N}} x_{\hat{N}} = b.\tag{4.19}\end{equation}</script>
</div>
<p>
 By construction <script type="math/tex">x_{\hat{N}} = 0</script> and so <script type="math/tex">A_{\hat{B}} x_{\hat{B}} = b</script>. 
</p>
<p>
We need to show that <script type="math/tex">A_{\hat{B}}</script> is a basic matrix. We do this by contradiction. Assume the columns of <script type="math/tex">A_{\hat{B}}</script> are not linearly independent. Then there is some <script type="math/tex">y_{\hat{B}} \ne 0</script> such that <script type="math/tex">A_{\hat{B}} y_{\hat{B}} = 0</script>. By construction <script type="math/tex">x_{\hat{B}} > 0</script>. Therefore there is some constant <script type="math/tex">\epsilon > 0</script> such that 
</p>
<div class="eqn" id="a0000000290">
<script type="math/tex; mode=display">\begin{equation}x_{\hat{B}} - \epsilon y_{\hat{B}} \ge 0 \;  \text{and} \;  x_{\hat{B}} + \epsilon y_{\hat{B}} \ge 0.\tag{4.20}\end{equation}</script>
</div>
<p>
 Also by construction we have 
</p>
<div class="eqn" id="a0000000291">
<script type="math/tex; mode=display">\begin{equation}A_{\hat{B}} \left( x_{\hat{B}} \pm \epsilon y_{\hat{B}} \right) = b.\tag{4.21}\end{equation}</script>
</div>
<p>
 Thus the two distinct points <script type="math/tex">(x_{\hat{B}} \pm \epsilon y_{\hat{B}}, 0)</script> are feasible solutions to <script type="math/tex">A x = b</script>. Finally, note that 
</p>
<div class="eqn" id="a0000000292">
<script type="math/tex; mode=display">\begin{equation}x = (x_{\hat{B}}, 0) = \frac{1}{2} \left( x_{\hat{B}} - \epsilon y_{\hat{B}} \right) + \frac{1}{2} \left( x_{\hat{B}} + \epsilon y_{\hat{B}} \right)\tag{4.22}\end{equation}</script>
</div>
<p>
 This shows that <script type="math/tex">x</script> can be written as the convex combination of two distinct feasible points. This contradicts <script type="math/tex">x</script> being a vertex. Therefore the columns of <script type="math/tex">A_{\hat{B}}</script> are linearly independent. 
</p>
<p>
To show that <script type="math/tex">A_{\hat{B}}</script> is basic we need to show that it is a square matrix. If <script type="math/tex">| \hat{B} | = m</script> then the proof is complete. If not, we can select more indices from <script type="math/tex">\hat{N}</script> so that the columns of the enlarged <script type="math/tex">A_{\hat{B}}</script> are linearly independent. This is possible as <script type="math/tex">A</script> has full row rank. The solution will then be degenerate - it will have basic variables with zero value - but remain basic. 
</p>
</div>
</div>
</section>
</section><section class="section">
<h2 id="a0000000293">4.5 Optimality</h2>
<p>
The previous sections have shown how to algebraically characterise a vertex (and we remember that the optimal solution must lie on some vertex): a vertex corresponds to a basic feasible solution. We now want to understand how to check if a vertex (or equivalently a basic feasible solution) is optimal, without enumerating all cases. 
</p>
<section class="subsection">
<h3 id="a0000000294">4.5.1 Reduced costs</h3>
<p>
Remember that the linear program can be written in basic form, with some basic matrix <script type="math/tex">A_ B</script>, as 
</p>
<div class="eqn" id="a0000000295">
<script type="math/tex; mode=display">\begin{equation}\tag{\ref{eq:simplex:basic-form}} \begin{array}{l@{\quad }rcl} \min &  c_ B A_ B^{-1} b + \left( c_ N - c_ B A_ B^{-1} A_ N \right) x_ N & +&  \left( c_ B - c_ B A_ B^{-1} A_ B \right) x_ B \\ \text{subject to} &  x_ B + A_ B^{-1} A_ N x_ N &  = &  A_ B^{-1} b \\ &  x_ B &  \ge &  0 \\ &  x_ N &  \ge &  0. \end{array}\tag{4.23}\end{equation}</script>
</div>
<p>
 Certain terms are sufficiently important to get names, which are all types of <em>reduced costs</em>: 
</p>
<div id="a0000000296">
<div class="eqnarrayid" id="a0000000297"></div><div class="eqnarrayid" id="a0000000298"></div><div class="eqnarrayid" id="a0000000299"></div><script type="math/tex; mode=display">
\begin{align}
\tag{4.24} \bar{c}_ N & = c_ N - c_ B A_ B^{-1} A_ N &  \text{reduced costs of non-basic variables}, \\ 
\tag{4.25}\bar{c}_ B & = c_ B - c_ B A_ B^{-1} A_ B &  \text{reduced costs of basic variables}, \\ 
\tag{4.26}\bar{c} & = c - c_ B A_ B^{-1} A &  \text{reduced costs (of the variables)}. 
\end{align}
</script>
</div>
<p>
 Note that by construction <script type="math/tex">\bar{c}_ B = 0</script> automatically. We also note that <script type="math/tex">\bar{c} = (\bar{c}_ B, \bar{c}_ N)</script> in a similar fashion to the split of a solution into basic and non-basic pieces (this can be checked explicitly using the matrix form split). 
</p>
<p>
In terms of the reduced costs the basic form linear program is 
</p>
<div class="eqn" id="eq:simplex:basic-reduced-form">
<script type="math/tex; mode=display">\begin{equation}\label{eq:simplex:basic-reduced-form} \begin{array}{l@{\quad }rcl} \min &  c_ B A_ B^{-1} b + \bar{c}_ N x_ N + \bar{c}_ B x_ B & & \\ \text{subject to} &  x_ B + A_ B^{-1} A_ N x_ N &  = &  A_ B^{-1} b \\ &  x_ B &  \ge &  0 \\ &  x_ N &  \ge &  0. \end{array}\tag{4.27}\end{equation}</script>
</div>
<p>
 This emphasises, as <script type="math/tex">\bar{c}_ B = 0</script>, that <script type="math/tex">x_ B</script> has no impact on the objective function. It also gives us an interpretation of the reduced costs of the non-basic variables: the component <script type="math/tex">(\bar{c}_ N)_ j</script> is equal to the change in the objective function value when changing the non-basic variable <script type="math/tex">(x_ N)_ j</script> by one unit. 
</p>
<p>
Therefore, if we start from a basic feasible solution (where, by construction, <script type="math/tex">x_ N = 0</script>), we can improve (make smaller) the objective function by increasing any component <script type="math/tex">(x_ N)_ j</script> where the corresponding component of the reduced cost is negative, <script type="math/tex">(\bar{c}_ N)_ j < 0</script>. 
</p>
</section><section class="subsection">
<h3 id="a0000000300">4.5.2 Optimality test</h3>
<p>
<div class="thmwrapper thm_thmwrapper" id="a0000000301">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">5.1</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
If, given a basic feasible solution <script type="math/tex">x</script> with basis <script type="math/tex">B</script>, the reduced cost vector <script type="math/tex">\bar{c}</script> is non-negative, then <script type="math/tex">x</script> is optimal. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000302">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
We show that, for any other feasible solution <script type="math/tex">y</script>, <script type="math/tex">c y \ge c x</script>. To do this define <script type="math/tex">d = y - x</script>. As 
</p>
<div id="a0000000303">
<div class="eqnarrayid" id="a0000000304"></div><div class="eqnarrayid" id="a0000000305"></div><div class="eqnarrayid" id="a0000000306"></div><script type="math/tex; mode=display">
\begin{align}
\tag{4.28}& &  c y & \ge c x \\ 
\tag{4.29}\iff & &  c (y - x) & \ge 0 \\ 
\tag{4.30}\iff & &  c d \ge 0, 
\end{align}
</script>
</div>
<p>
 we are looking to prove <script type="math/tex">c d \ge 0</script>. 
</p>
<p>
Since <script type="math/tex">x</script> and <script type="math/tex">y</script> are both feasable solutions we have <script type="math/tex">A x = b</script> and <script type="math/tex">A y = b</script>, implying 
</p>
<div id="a0000000307">
<div class="eqnarrayid" id="a0000000308"></div><div class="eqnarrayid" id="a0000000309"></div><div class="eqnarrayid" id="a0000000310"></div><script type="math/tex; mode=display">
\begin{align}
\tag{4.31} A d & = A(x - y) \\ 
\tag{4.32}& = A x - A y \\ 
\tag{4.33}& = 0. 
\end{align}
</script>
</div>
<p>
 Writing <script type="math/tex">d = (d_ B, d_ N)</script> as usual we have 
</p>
<div id="a0000000311">
<div class="eqnarrayid" id="a0000000312"></div><div class="eqnarrayid" id="a0000000313"></div><script type="math/tex; mode=display">
\begin{align}
\tag{4.34}& &  A d & = 0 \\ 
\tag{4.35}\iff & &  A_ B d_ B + A_ N d_ N & = 0. 
\end{align}
</script>
</div>
<p>
 The basic matrix <script type="math/tex">A_ B</script> is non-singular by construction, so 
</p>
<div class="eqn" id="a0000000314">
<script type="math/tex; mode=display">\begin{equation}d_ B = - A_ B^{-1} A_ N d_ N.\tag{4.36}\end{equation}</script>
</div>
<p>
 We can then evaluate 
</p>
<div id="a0000000315">
<div class="eqnarrayid" id="a0000000316"></div><div class="eqnarrayid" id="a0000000317"></div><div class="eqnarrayid" id="a0000000318"></div><div class="eqnarrayid" id="a0000000319"></div><script type="math/tex; mode=display">
\begin{align}
\tag{4.37} c d & = c_ B d_ B + c_ N d_ N \\ 
\tag{4.38}& = c_ B \left(- A_ B^{-1} A_ N d_ N\right) + c_ N d_ N \\ 
\tag{4.39}& = \left( c_ N - c_ B A_ B^{-1} A_ N \right) d_ N \\ 
\tag{4.40}& = \bar{c}_ N d_ N. 
\end{align}
</script>
</div>
<p>
 By assumption we have <script type="math/tex">\bar{c}_ N \ge 0</script>. To show that <script type="math/tex">c d \ge 0</script> we need to show that <script type="math/tex">d_ N = y_ N - x_ N \ge 0</script>. 
</p>
<p>
We note that <script type="math/tex">y</script> is a feasible solution which implies that <script type="math/tex">y_ N \ge 0</script>. Similarly <script type="math/tex">x</script> is a <em>basic</em> feasible solution which requires that <script type="math/tex">x_ N = 0</script>. Hence <script type="math/tex">d_ N \ge 0</script>, implying that <script type="math/tex">c d \ge 0</script> and hence <script type="math/tex">c y \ge c x</script>. Thus any feasible solution that is not <script type="math/tex">x</script> increases the value of the objective function, meaning <script type="math/tex">x</script> is optimal. 
</p>
</div>
</div>
</section>
</section><section class="section">
<h2 id="a0000000320">4.6 Moving between vertices</h2>
<p>
We now have both a characterisation of vertices (as basic feasible solutions) and a test of their optimality (the associated reduced cost vector is non-negative). If we can easily move from one vertex to another then we have (most of) the ingredients of an algorithm. 
</p>
<p>
We know intuitively that a vertex is connected to a neighbouring vertex by an edge; a one dimensional boundary line of the feasible region. We know a vertex corresponds to a basic feasible solution. The basis <script type="math/tex">B</script> is the set of indices defining which variables are basic at a particular vertex, and has complement <script type="math/tex">N</script>. If we move along an edge we might expect to only be changing two variables (in an appropriate coordinate system the one dimensional line defining the edge lies in a two dimensional plane spanned by two basis vectors). Therefore, moving along an edge from one vertex to another corresponds to <em>swapping one non-basic variable with one basic variable</em>. This is equivalent to swapping one entry of <script type="math/tex">N</script> with one entry of <script type="math/tex">B</script>. 
</p>
<section class="subsection">
<h3 id="a0000000321">4.6.1 Minimum ratio test</h3>
<p>
We go back to our linear program 
</p>
<div class="eqn" id="a0000000322">
<script type="math/tex; mode=display">\begin{equation}\tag{\ref{eq:simplex:basic-reduced-form}} \begin{array}{l@{\quad }rcl} \min &  c_ B A_ B^{-1} b + \bar{c}_ N x_ N + \bar{c}_ B x_ B & & \\ \text{subject to} &  x_ B + A_ B^{-1} A_ N x_ N &  = &  A_ B^{-1} b \\ &  x_ B &  \ge &  0 \\ &  x_ N &  \ge &  0. \end{array}\tag{4.41}\end{equation}</script>
</div>
<p>
 For compactness define <script type="math/tex">\bar{A} = A_ B^{-1} A_ N</script> and <script type="math/tex">\bar{b} = A_ B^{-1} b</script>, so the system of equations becomes 
</p>
<div class="eqn" id="a0000000323">
<script type="math/tex; mode=display">\begin{equation}x_ B + \bar{A} x_ N = \bar{b}.\tag{4.42}\end{equation}</script>
</div>
<p>
 For each single row <script type="math/tex">i \in \{  1, \dots , m \} </script> we can write this explicitly as 
</p>
<div class="eqn" id="a0000000324">
<script type="math/tex; mode=display">\begin{equation}(x_ B)_ i + \sum _{j \in N} \bar{a}_{ij} (x_ N)_ j = \bar{b}_ i.\tag{4.43}\end{equation}</script>
</div>
<p>
Now, if <script type="math/tex">x</script> corresponds to a vertex then it is a basic feasible solution so that <script type="math/tex">x_ N = 0</script>. We assume at this point that some component has negative reduced cost. That is, <script type="math/tex">\exists s \in N</script> such that <script type="math/tex">\bar{c}_ s < 0</script>. It must be the case that <script type="math/tex">s \in N</script> (if one exists) as <script type="math/tex">\bar{c}_ B = 0</script> automatically. Therefore we can improve the value of the objective function by increasing the value of <script type="math/tex">x_ s</script> (and hence removing <script type="math/tex">s</script> from <script type="math/tex">N</script>). The constraints then require that 
</p>
<div class="eqn" id="a0000000325">
<script type="math/tex; mode=display">\begin{equation}(x_ B)_ i = \bar{b}_ i - \bar{a}_{is} x_ s.\tag{4.44}\end{equation}</script>
</div>
<p>
 There is no sum as all terms in <script type="math/tex">N</script> are still basic, so <script type="math/tex">(x_ N)_ j = 0</script> for all <script type="math/tex">j \in N \setminus \{  s \} </script>. 
</p>
<p>
We also need to retain all the positivity constraints <script type="math/tex">(x_ B)_ i \ge 0</script>. This requires that 
</p>
<div class="eqn" id="a0000000326">
<script type="math/tex; mode=display">\begin{equation}\bar{b}_ i - \bar{a}_{is} x_ s \ge 0.\tag{4.45}\end{equation}</script>
</div>
<p>
 If <script type="math/tex">\bar{a}_{is} \le 0</script> this cannot cause a problem: increasing <script type="math/tex">x_ s</script> can never violate this constraint. However, if <script type="math/tex">\bar{a}_{is} > 0</script> then this implies that we must impose 
</p>
<div class="eqn" id="a0000000327">
<script type="math/tex; mode=display">\begin{equation}x_ s \le \frac{\bar{b}_ i}{\bar{a}_{is}} .\tag{4.46}\end{equation}</script>
</div>
<p>
 As we need this condition to hold for all constraints, this means we must impose 
</p>
<div class="eqn" id="a0000000328">
<script type="math/tex; mode=display">\begin{equation}x_ s \le \min _{i \in B \colon \bar{a}_{is} > 0} \frac{\bar{b}_ i}{\bar{a}_{is}} .\tag{4.47}\end{equation}</script>
</div>
<p>
We use this to define the intermediate variable 
</p>
<div class="eqn" id="a0000000329">
<script type="math/tex; mode=display">\begin{equation}\theta ^* = \min _{i \in B \colon \bar{a}_{is} > 0} \frac{\bar{b}_ i}{\bar{a}_{is}} .\tag{4.48}\end{equation}</script>
</div>
<p>
 If <script type="math/tex">\theta ^* > 0</script> then setting <script type="math/tex">x_ s = \theta ^*</script> ensures that 
</p>
<ul class="itemize" id="a0000000330">
<li id="a0000000331"> <p>
<script type="math/tex">x_ s</script> becomes basic (so that <script type="math/tex">s</script> moves from <script type="math/tex">N</script> to <script type="math/tex">B</script>); 
</p>
</li>
<li id="a0000000332"> <p>
The value of every variable <script type="math/tex">(x_ B)_ r</script> with 
</p>
<div class="eqn" id="a0000000333">
<script type="math/tex; mode=display">\begin{equation}r \in \operatorname*{argmin}_{i \in B \colon \bar{a}_{is} > 0} \frac{\bar{b}_ i}{\bar{a}_{is}}\tag{4.49}\end{equation}</script>
</div>
<p>
 is decreased to zero. We can select any one of these variables to leave the basis (so that <script type="math/tex">r</script> moves from <script type="math/tex">B</script> to <script type="math/tex">N</script>), whilst the others remain (with value zero). 
</p>
</li>
</ul>
<p>
This gives us a recipe for moving from vertex to vertex: find the value of <script type="math/tex">\theta ^*</script> for given index <script type="math/tex">s</script> and an index <script type="math/tex">r</script> that gives the minimum. Swap <script type="math/tex">s</script> and <script type="math/tex">r</script>. This is the <em>minimum ratio test</em>. 
</p>
<p>
We restricted to the case where <script type="math/tex">\bar{a}_{is} > 0</script> when computing the minimum ratio as the other case does not violate the positivity constraint. However, we also need to consider the objective function. <div class="thmwrapper thm_thmwrapper" id="a0000000334">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">6.1</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
If there is an index <script type="math/tex">s</script> such that <script type="math/tex">\bar{c}+s < 0</script> with <script type="math/tex">\bar{a}_{is} \le 0</script> for every row <script type="math/tex">i \in \{  1, \dots , m \} </script>, the linear program is unbounded. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000335">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
Since <script type="math/tex">\bar{a}_{is} \le 0</script> for all <script type="math/tex">i</script>, <script type="math/tex">x_ s</script> can be increased indefinitely without violating any constraint. As <script type="math/tex">\bar{c}_ s < 0</script> the objective function can be improved indefinitely. 
</p>
</div>
</div>
</section><section class="subsection">
<h3 id="a0000000336">4.6.2 Degeneracy</h3>
<p>
We have seen with the minimum ratio test that it possible to have a basic feasible solution with at least one basic variable having zero value. These solutions are called <em>degenerate</em>. 
</p>
<p>
Degenerate solutions can cause problems as different degenerate basic feasible solutions can correspond to the same vertex. To show this, consider a basic feasible solution which is degenerate for some row, index <script type="math/tex">\hat{\imath }</script>, so that 
</p>
<div class="eqn" id="a0000000337">
<script type="math/tex; mode=display">\begin{equation}(x_ B)_{\hat{\imath }} = \bar{b}_{\hat{\imath }} = 0.\tag{4.50}\end{equation}</script>
</div>
<p>
 Assume we want to increase the value of the non-basic variable <script type="math/tex">x_ s</script>, <script type="math/tex">s \in N</script>, which starts from zero. As usual we need 
</p>
<div class="eqn" id="a0000000338">
<script type="math/tex; mode=display">\begin{equation}\bar{b}_{\hat{\imath }} - \bar{a}_{\hat{\imath }s} x_ s \ge 0\tag{4.51}\end{equation}</script>
</div>
<p>
 to ensure that <script type="math/tex">(x_ B)_{\hat{\imath }} \ge 0</script>. If the problem is not unbounded then the minimum ratio test gives 
</p>
<div class="eqn" id="a0000000339">
<script type="math/tex; mode=display">\begin{equation}\theta ^* = \min _{i \in B \colon \bar{a}_{is} > 0} \frac{\bar{b}_ i}{\bar{a}_{is}} = 0,\tag{4.52}\end{equation}</script>
</div>
<p>
 as <script type="math/tex">\hat{\imath } \in B</script> and <script type="math/tex">\bar{b}_{\hat{\imath }} = 0</script>. 
</p>
<p>
Thus the non-basic variable <script type="math/tex">x_ s</script> enters the basis but remains at value zero, whilst the basic variable <script type="math/tex">(x_ B)_{\hat{\imath }}</script> leaves the basis and also remains at value zero. So, in spite of changing the basis <script type="math/tex">B</script> the values of <script type="math/tex">x</script> are unchanged. Therefore we have not actually moved to a different vertex. 
</p>
</section><section class="subsection">
<h3 id="a0000000340">4.6.3 Cycling and Bland’s rule</h3>
<p>
If there is a degenerate solution the simplex method (using the minimum ratio test to move from one vertex to another) my enter an endless loop in which the the same basic and non-basic variables are swapped in and out of the basis forever. <script type="math/tex">B</script> and <script type="math/tex">N</script> would be changing but <script type="math/tex">x</script> would remain the same. 
</p>
<p>
The problem arises as there are multiple choices of indexes to move out of the basis. We need a rule to choose which indexes to use, so that this rule ensures a cycle cannot occur. 
</p>
<p>
<em>Bland’s rule</em> is the following method: 
</p>
<ul class="itemize" id="a0000000341">
<li id="a0000000342"> <p>
Among all <script type="math/tex">s \in \{  1, \dots , n \} </script> with <script type="math/tex">\bar{c}_ s < 0</script>, choose the smallest <script type="math/tex">s</script>. 
</p>
</li>
<li id="a0000000343"> <p>
Among all <script type="math/tex">r \in \operatorname*{argmin}_{i \in B \colon \bar{a}_{is} > 0} \frac{\bar{b}_ i}{\bar{a}_{is}}</script>, choose the smallest <script type="math/tex">r</script>. 
</p>
</li>
</ul>
<p>
<div class="thmwrapper thm_thmwrapper" id="a0000000344">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">6.2</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
With Bland’s rule, the simplex method converges in a finite number of iterations. 
</p>
</div>
</div> We will not show the proof here - there is some discussion in Chvátal. 
</p>
</section>
</section><section class="section">
<h2 id="a0000000345">4.7 Summary</h2>
<p>
The simplex method with Bland’s rule starts from the linear program 
</p>
<div class="eqn" id="a0000000346">
<script type="math/tex; mode=display">\begin{equation}\tag{\ref{eq:simplex:basic-reduced-form}} \begin{array}{l@{\quad }rcl} \min &  c_ B A_ B^{-1} b + \bar{c}_ N x_ N + \bar{c}_ B x_ B & & \\ \text{subject to} &  x_ B + \bar{A} x_ N &  = &  \bar{b} \\ &  x_ B &  \ge &  0 \\ &  x_ N &  \ge &  0. \end{array}\tag{4.53}\end{equation}</script>
</div>
<p>
 Start the algorithm with a basis <script type="math/tex">B \subseteq \{  1, \dots , n \} </script> with a basic matrix <script type="math/tex">A_ B</script> yielding a basic feasible solution <script type="math/tex">x_ B = A_ B^{-1} b \ge 0</script> with <script type="math/tex">x_ N = 0</script>. 
</p>
<p>
At each step of the simplex method, then 
</p>
<ol class="enumerate" id="a0000000347" style="list-style: none">
<li id="a0000000348" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
Compute 
</p>
<ul class="itemize" id="a0000000349">
<li id="a0000000350"> <p>
<script type="math/tex">A_ B^{-1}</script>, 
</p>
</li>
<li id="a0000000351"> <p>
<script type="math/tex">\bar{A} = A_ B^{-1} A_ N</script>, 
</p>
</li>
<li id="a0000000352"> <p>
<script type="math/tex">\bar{b} = A_ B^{-1} b</script>, 
</p>
</li>
<li id="a0000000353"> <p>
<script type="math/tex">\bar{c} = c - c_ B A_ B^{-1} A</script>. 
</p>
</li>
</ul>
</li>
<li id="a0000000354" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
If <script type="math/tex">| \{  s \in \{  1, \dots , n \}  \colon \bar{c}_ s < 0 \}  | > 0</script>, then 
</p>
<ul class="itemize" id="a0000000355">
<li id="a0000000356"> <p>
Pick the smallest index <script type="math/tex">s \in \{  1, \dots , n \} </script> with <script type="math/tex">\bar{c}_ s < 0</script>; 
</p>
</li>
<li id="a0000000357"> <p>
Pick the smallest index <script type="math/tex">r</script> where 
</p>
<div class="eqn" id="a0000000358">
<script type="math/tex; mode=display">\begin{equation}r \in \operatorname*{argmin}_{i \in B \colon \bar{a}_{is} > 0} \frac{\bar{b}_ i}{\bar{a}_{is}}.\tag{4.54}\end{equation}</script>
</div>
<p>
 If there is no such index then the problem is unbounded; 
</p>
</li>
<li id="a0000000359"> <p>
Let <script type="math/tex">B \to B \setminus \{  r \}  \cup \{  s \} </script>. 
</p>
</li>
</ul>
</li>
<li id="a0000000360" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		3.
	</span>
<p>
Else we have reached the optimal solution. Stop, returning <script type="math/tex">x = (x_ B, x_ N)</script> with <script type="math/tex">x_ B = A_ B^{-1}</script> and <script type="math/tex">x_ N = 0</script>. 
</p>
</li>
</ol>
</section><section class="section">
<h2 id="a0000000361">4.8 Tableau form</h2>
<p>
The simplex method as summarised above is a working algorithm. However, it is not in the most efficient form to implement on a computer. In part this is because there are many different variables to compute and manipulate. In part it is because some of the calculations (such as the explicit matrix inversion of <script type="math/tex">A_ B</script>) are expensive. 
</p>
<p>
We can build on a number of concepts from linear algebra to make the algorithm more efficiently implemented. 
</p>
<section class="subsection">
<h3 id="a0000000362">4.8.1 The problem as a block matrix</h3>
<p>
We again start from the standard basic form linear program 
</p>
<div class="eqn" id="a0000000363">
<script type="math/tex; mode=display">\begin{equation}\tag{\ref{eq:simplex:basic-reduced-form}} \begin{array}{l@{\quad }rcl} \min &  c_ B A_ B^{-1} b + \bar{c}_ N x_ N + \bar{c}_ B x_ B & & \\ \text{subject to} &  x_ B + \bar{A} x_ N &  = &  \bar{b} \\ &  x_ B &  \ge &  0 \\ &  x_ N &  \ge &  0. \end{array}\tag{4.55}\end{equation}</script>
</div>
<p>
 We transfer the problem to the <em>tableau</em>
</p>
<div class="eqn" id="a0000000364">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{|c|c|c|} \hline -c_ B A_ B^{-1} b &  \bar{c}_ B &  \bar{c}_ N \\ \hline \bar{b} &  I &  \bar{A} \\ \end{array}\tag{4.56}\end{equation}</script>
</div>
<p>
 The objective function is contained in the first row, row <script type="math/tex">0</script>. The value in position <script type="math/tex">(0, 0)</script> is the (negative of the) objective function value of the current basic solution. Rows <script type="math/tex">1</script> to <script type="math/tex">m</script> contain the constraints. The right hand side <script type="math/tex">\bar{b}</script> is in column <script type="math/tex">0</script>. The <script type="math/tex">m</script> rows and columns corresponding to the basic variables are those of the identity matrix <script type="math/tex">I</script>, as the constraints have been written as <script type="math/tex">x_ B + \bar{A} x_ N = \bar{b}</script> in this form of the linear program. Each row corresponds to a specific basic variable. 
</p>
<p>
To complete the simplex method we need to apply Bland’s rule and the minimum ratio test and then swap our chosen basic and non-basic variables. 
</p>
<ol class="enumerate" id="a0000000365" style="list-style: none">
<li id="a0000000366" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
Look at row zero, all columns except column zero. This contains the reduced costs. If any entry is negative we are not optimal and must continue. 
</p>
</li>
<li id="a0000000367" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
Using Bland’s rule, set <script type="math/tex">s</script> as the index of the first column containing a negative reduced cost. 
</p>
</li>
<li id="a0000000368" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		3.
	</span>
<p>
Using Bland’s rule and the minimum rate test, set <script type="math/tex">r</script> as the row index with the minimum ratio, only considering rows <script type="math/tex">i</script> where <script type="math/tex">\bar{a}_{is} > 0</script>, and taking the ratio with <script type="math/tex">\bar{b}_ i</script>, which is in column zero of the tableau. 
</p>
</li>
<li id="a0000000369" value="4">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		4.
	</span>
<p>
Perform a <em>pivot</em> operation so that the tableau entry <script type="math/tex">\bar{a}_{rs} = 1</script> and every other entry in column <script type="math/tex">s</script>, corresponding to <script type="math/tex">\bar{a}_{is}</script>, is set to zero. This swaps the basis and non-basis entries. 
</p>
</li>
</ol>
</section><section class="subsection">
<h3 id="a0000000370">4.8.2 Pivoting</h3>
<p>
Pivoting is the operation used in Gaussian Elimination to solve linear systems. It is highly efficient allowing us to move from one basic solution to another without explicitly constructing a lot of intermediate terms. Pivoting consists of two steps. Given a matrix <script type="math/tex">A</script> and a pair of row-column indexes <script type="math/tex">(r, s)</script> with <script type="math/tex">a_{rs} \ne 0</script>, the steps are 
</p>
<ol class="enumerate" id="a0000000371" style="list-style: none">
<li id="a0000000372" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
Divide the <script type="math/tex">r^{\text{th}}</script> row by <script type="math/tex">a_{rs}</script>; 
</p>
</li>
<li id="a0000000373" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
For each row with index <script type="math/tex">i \ne r</script>, subtract the <script type="math/tex">r^{\text{th}}</script> row multiplied by <script type="math/tex">a_{is}</script>
</p>
</li>
</ol>
<p>
 The first step ensures that <script type="math/tex">a_{rs} \to 1</script>. The second step ensures that <script type="math/tex">a_{is} \to 0</script> for all <script type="math/tex">i \ne r</script>. 
</p>
<p>
After the pivoting operation the column with index <script type="math/tex">s</script> becomes equal to a column of the identity matrix. That means that the variable <script type="math/tex">s</script> is now basic. Because the basic variables have columns that match those in the identity matrix, the pivoting operation will only change the contents of column <script type="math/tex">r</script>. Therefore the pivoting operation swaps <script type="math/tex">(x_ B)_ r</script> and <script type="math/tex">x_ s</script> as expected. 
</p>
</section>
</section><section class="section">
<h2 id="a0000000374">4.9 Two-phase simplex method</h2>
<p>
We now, via the simplex method in tableau form, have an efficient algorithm for solving a linear program. However, it is not a general algorithm: it requires that the linear program is in basic form, 
</p>
<div class="eqn" id="a0000000375">
<script type="math/tex; mode=display">\begin{equation}\tag{\ref{eq:simplex:basic-reduced-form}} \begin{array}{l@{\quad }rcl} \min &  c_ B A_ B^{-1} b + \bar{c}_ N x_ N + \bar{c}_ B x_ B & & \\ \text{subject to} &  x_ B + \bar{A} x_ N &  = &  \bar{b} \\ &  x_ B &  \ge &  0 \\ &  x_ N &  \ge &  0, \end{array}\tag{4.57}\end{equation}</script>
</div>
<p>
 before it can start. We need to work out how to get a linear program in, for example, the standard form 
</p>
<div class="eqn" id="a0000000376">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl} \min &  c x & & \\ \text{subject to} &  A x &  = &  b \\ &  x &  \ge &  0, \end{array}\tag{4.58}\end{equation}</script>
</div>
<p>
 into the basic form before we can use the simplex method. 
</p>
<p>
The two-phase simplex method is the approach to use. This 
</p>
<ol class="enumerate" id="a0000000377" style="list-style: none">
<li id="a0000000378" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
iteratively constructs <em>some</em> basic feasible solution and from it the associated basic feasible tableau; 
</p>
</li>
<li id="a0000000379" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
applies the tableau simplex method to find the optimal solution. 
</p>
</li>
</ol>
<p>
 An important part of the first phase is that, by constructing <em>some</em> basic feasible solution it shows that the problem is feasible. If the first phase fails it means the problem is infeasible. 
</p>
<section class="subsection">
<h3 id="a0000000380">4.9.1 Auxiliary problem</h3>
<p>
Define the vector <script type="math/tex">e = (1, \dots , 1)</script> with <script type="math/tex">m</script> components. Starting from the linear program in standard form, 
</p>
<div class="eqn" id="a0000000381">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl} \min &  c x & & \\ \text{subject to} &  A x &  = &  b \\ &  x &  \ge &  0, \end{array}\tag{4.59}\end{equation}</script>
</div>
<p>
 define the <em>auxiliary problem</em>
</p>
<div class="eqn" id="a0000000382">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl} \min &  e y & & \\ \text{subject to} &  A x + I y &  = &  b \\ &  x &  \ge &  0, \\ &  y &  \ge &  0. \end{array}\tag{4.60}\end{equation}</script>
</div>
<p>
 Note that <script type="math/tex">e y = \|  y \| _1</script> as <script type="math/tex">y \ge 0</script>. This problem is trying to find the “smallest” <script type="math/tex">y</script> (in the one norm) such that <script type="math/tex">A x + I y = b</script>. 
</p>
<p>
<div class="thmwrapper thm_thmwrapper" id="a0000000383">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">9.1</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
The auxiliary problem admits an optimal solution <script type="math/tex">(x^*, y^*)</script> with <script type="math/tex">e y^* = 0</script> if, and only if, the original problem is feasible. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000384">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
For the implication, work by contradiction. Assume there is an optimal solution <script type="math/tex">(x^*, y^*)</script> with <script type="math/tex">e y^* > 0</script>. Therefore there is no solution <script type="math/tex">(x', y')</script> with <script type="math/tex">x' \ge 0</script> and <script type="math/tex">y' = 0</script> satisfying <script type="math/tex">A x' + I y' = A x' = b</script>. This is because any such solution would have objective function value <script type="math/tex">e y' = 0 < e y^*</script>, which is a contradiction. 
</p>
<p>
Finally, if the original problem admits a feasible solution <script type="math/tex">x'</script> then the pair <script type="math/tex">(x', y')</script> with <script type="math/tex">y' = 0</script> is feasible for the auxiliary problem. It is also optimal as the objective function <script type="math/tex">e y' = 0</script>, which is the minimum as <script type="math/tex"> e, y' \ge 0</script>. 
</p>
</div>
</div>
<p>
 Note that it immediately follows from the proof that if the auxiliary problem does not admit an optimal solution the linear program is infeasible. 
</p>
</section><section class="subsection">
<h3 id="a0000000385">4.9.2 Phase 1 tableau</h3>
<p>
The auxiliary problem as constructed automatically contains an identity matrix corresponding to the columns associated with <script type="math/tex">y</script>. It immediately follows that <script type="math/tex">y</script> is basic. Therefore we can immediately write down the tableau 
</p>
<div class="eqn" id="a0000000386">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{|c|c|c|} \hline 0 &  0 &  1, \dots , 1 \\ \hline b &  A &  I \\ \end{array}\tag{4.61}\end{equation}</script>
</div>
<p>
 This is, however, not completely in the tableau form that we require for the simplex method. The issue is the reduced cost vector of the basic variables. To start the simplex method we need the reduced costs to be <script type="math/tex">0</script>: here they are <script type="math/tex">1</script>. This has been caused by expressing the objective function in terms of the basic variables. We instead want to express the objective function solely in terms of the non-basic variables. To do this, use 
</p>
<div id="a0000000387">
<div class="eqnarrayid" id="a0000000388"></div><div class="eqnarrayid" id="a0000000389"></div><div class="eqnarrayid" id="a0000000390"></div><script type="math/tex; mode=display">
\begin{align}
\tag{4.62}& &  A x + I y & = b \\ 
\tag{4.63}\implies & &  y & = b - A x \\ 
\tag{4.64}\implies & &  e y & = e b - e A x. 
\end{align}
</script>
</div>
<p>
 By re-writing the objective function in this form we have the tableau 
</p>
<div class="eqn" id="a0000000391">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{|c|c|c|} \hline -e b &  -e A &  0, \dots , 0 \\ \hline b &  A &  I \\ \end{array}\tag{4.65}\end{equation}</script>
</div>
<p>
 We can now apply the simplex method to the auxiliary problem. 
</p>
</section><section class="subsection">
<h3 id="a0000000392">4.9.3 Outline of two-phase method</h3>
<p>
Assume we are starting from the standard form of the linear program, 
</p>
<div class="eqn" id="a0000000393">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl} \min &  c x & & \\ \text{subject to} &  A x &  = &  b \\ &  x &  \ge &  0, \end{array}\tag{4.66}\end{equation}</script>
</div>
<p>
 construct the tableau for the auxiliary problem as 
</p>
<div class="eqn" id="a0000000394">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{|c|c|c|} \hline -e b &  -e A &  0, \dots , 0 \\ \hline b &  A &  I \\ \end{array}\tag{4.67}\end{equation}</script>
</div>
<p>
Then 
</p>
<ol class="enumerate" id="a0000000395" style="list-style: none">
<li id="a0000000396" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
Solve the auxiliary problem. Let <script type="math/tex">(x^*, y^*)</script> be an optimal solution. 
</p>
<ol class="enumerate" id="a0000000397" style="list-style: none">
<li id="a0000000398" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(a)
	</span>
<p>
If the optimal objective function value <script type="math/tex">e y^* > 0</script> the original problem is infeasible. Stop at this point. 
</p>
</li>
<li id="a0000000399" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		(b)
	</span>
<p>
If <script type="math/tex">e y^* = 0</script> then 
</p>
<ol class="enumerate" id="a0000000400" style="list-style: none">
<li id="a0000000401" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		i.
	</span>
<p>
If there is some basic variable <script type="math/tex">y_ i</script> with zero value the auxiliary problem is degenerate. Each such basic <script type="math/tex">y_ i</script> can be made non-basic by pivoting on any non-zero component of its row. 
</p>
</li>
<li id="a0000000402" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		ii.
	</span>
<p>
Delete all columns corresponding to the basic <script type="math/tex">y_ i</script> variables. 
</p>
</li>
<li id="a0000000403" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		iii.
	</span>
<p>
Re-write the objective function in terms of the non-basic <script type="math/tex">x_ j</script> variables. 
</p>
</li>
</ol>
</li>
</ol>
</li>
<li id="a0000000404" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
Rewrite the objective function of the original problem in terms of only the non-basic variables. 
</p>
</li>
<li id="a0000000405" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		3.
	</span>
<p>
Write the basic feasible tableau for the original problem using the basic solution found in phase 1. Apply the simplex method to it. 
</p>
</li>
</ol>
<p>
The issue of degeneracy in the auxiliary problem needs more explanation. If there is a degeneracy for <script type="math/tex">y_ i</script> then the tableau is in the form 
</p>
<div class="eqn" id="a0000000406">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{c|c|c|c|}& &  x_1 \dots x_ j \dots x_ n &  y_1 \dots y_ i \dots y_ m \\ \hline &  0 &  \dots &  \dots \\ \hline & & &  0 \\ & & &  \vdots \\ y_ i &  0 &  \bar{a}_{i1} \dots \bar{a}_{ij} \dots \bar{a}_{in} &  1 \\ & & &  \vdots \\ & & &  0 \\ \end{array}\tag{4.68}\end{equation}</script>
</div>
<p>
 Here we have added information about which rows and columns correspond to which variables at the top and left. This is the tableau once the simplex method has been run on the auxiliary problem, and the objective function is zero meaning a feasible solution exists. 
</p>
<p>
We can pivot on any <script type="math/tex">\bar{a}_{ij}</script> that is non-zero. The reason is that the value changes by <script type="math/tex">\bar{b_ i} / \bar{a}_{ij}</script>, and <script type="math/tex">\bar{b}_ i = 0</script>. This pivot operation ensures that <script type="math/tex">x_ j</script> enters the basis with value zero, and <script type="math/tex">y_ i</script> leaves the basis (also with value zero). 
</p>
<p>
If, however, there is no entry <script type="math/tex">\bar{a}_{ij}</script> that is non-zero, then the matrix <script type="math/tex">A</script> is not full rank. In this case the entire row (and hence variable <script type="math/tex">y_ i</script>) can be removed from the tableau immediately. 
</p>
</section>
</section><section class="section">
<h2 id="a0000000407">4.10 Efficiency and complexity</h2>
<p>
Our aim in deriving the simplex method was to avoid enumerating all the vertexes of the feasible region. The reason is that enumerating all vertexes has computational complexity <script type="math/tex">\mathcal{O}(n!)</script> which is not tractable. 
</p>
<p>
The simplex method works by finding one vertex and then moving to neighbouring vertexes one at a time. If the simplex method has to visit every vertex to find the optimal solution then it also has complexity <script type="math/tex">\mathcal{O}(n!)</script>. Unfortunately there are “pathological” cases where this can occur. 
</p>
<p>
<div class="thmwrapper thm_thmwrapper" id="a0000000408">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">10.1</span>
<span class="thmtitle thm_thmtitle">(Klee and Minty, 1972)</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
 The linear program 
</p>
<div class="eqn" id="a0000000409">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl@{\quad }l} \max &  \sum _{j=1}^ n 10^{n-j} x_ j & & & \\ \text{subject to} &  \left( 2 \sum _{j=1}^{i-1} 10^{i-j} x_ j \right) + x_ i &  \le &  100^{i-1}, &  i \in \{  1, \dots , n \}  \\ &  x_ j &  \ge &  0, &  j \in \{  1, \dots , n \} , \end{array}\tag{4.69}\end{equation}</script>
</div>
<p>
 requires <script type="math/tex">2^ n - 1</script> iterations to solve with the simplex method. 
</p>
</div>
</div>
</p>
<p>
Therefore the worst case analysis of the simplex method shows that it is intractable. <em>However</em>, when applied to “generic” problems in practical use the simplex method is (nearly always) fast. Empirically the computational complexity of the average case is <script type="math/tex">\mathcal{O}(m \log (n))</script>.  
</p>
</section><!-- Latex Chapter/Part -->
<h1 id="chap:ilp">Integer linear programs</h1>
<p>
So far we have considered linear programs of the form 
</p>
<div class="eqn" id="a0000000410">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl} \min &  c x & & \\ \text{subject to} &  A x &  \ge &  b \\ &  x &  \ge &  0 \\ &  x &  \in &  \mathbb {R}^ n. \end{array}\tag{5.1}\end{equation}</script>
</div>
<p>
 We have here made explicit that each component of <script type="math/tex">x</script> is a real number. In addition we have <script type="math/tex">A \in \mathbb {R}^{m \times n}, b \in \mathbb {R}^ m, c, x \in \mathbb {R}^ n</script> being matrices and vectors in the appropriate real spaces. 
</p>
<p>
There are a lot of applications where this does not make perfect sense. There are many situations where talking about half a person, or a third of a car, or similar, is meaningless. In these cases we instead need to consider the <em>integer linear program</em>
</p>
<div class="eqn" id="a0000000411">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl} \min &  c x & & \\ \text{subject to} &  A x &  \ge &  b \\ &  x &  \ge &  0 \\ &  x &  \in &  \mathbb {Z}^ n, \end{array}\tag{5.2}\end{equation}</script>
</div>
<p>
 where <script type="math/tex">A \in \mathbb {Q}^{m \times n}, b \in \mathbb {Q}^ m, c, x \in \mathbb {Q}^ n</script> are now matrices and vectors in the appropriate <em>rational</em> spaces. 
</p>
<p>
Another special case is where we have to make yes/no or true/false decisions. For this weconsider the <em>integer linear program</em>
</p>
<div class="eqn" id="a0000000412">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl} \min &  c x & & \\ \text{subject to} &  A x &  \ge &  b \\ &  x &  \ge &  0 \\ &  x &  \in &  \{  0, 1 \} ^ n, \end{array}\tag{5.3}\end{equation}</script>
</div>
<p>
 where again <script type="math/tex">A \in \mathbb {Q}^{m \times n}, b \in \mathbb {Q}^ m, c \in \mathbb {Q}^ n</script> are now matrices and vectors in the appropriate <em>rational</em> spaces. 
</p>
<section class="section">
<h2 id="a0000000413">5.1 Optimal solutions</h2>
<p>
The feasible region of an integer linear program is not a polyhedron. It is instead the intersection of a polyhedron with a lattice, where the lattice is a grid of integer points. This immediately implies that, in general, an integer linear program cannot be solved by the simplex method (as the “vertices” need not be optimal). This is illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:ilp:lattice">5.1</a>. 
</p>
<figure id="fig:ilp:lattice">
<p>
<img alt="The feasible region for an integer linear program is given by the intersection of the feasible region for the standard linear program (the blue shaded region) and the integer lattice. The black dots here form that restricted feasible region. The optimal solution for the standard problem (shown by the red dot) does not lie in this feasible region, although it is close to the optimal integer solution (as seen by the level curves of the objective function, given by the dashed lines)." src="../../notes/course_notes/images/img-0032.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">5.1</span>
<span class="caption_text">The feasible region for an integer linear program is given by the intersection of the feasible region for the standard linear program (the blue shaded region) and the integer lattice. The black dots here form that restricted feasible region. The optimal solution for the standard problem (shown by the red dot) does not lie in this feasible region, although it is close to the optimal integer solution (as seen by the level curves of the objective function, given by the dashed lines).</span>
</figcaption>
</figure>
<p>
We can, however, solve the linear program <em>relaxation</em> of an integer linear program. This is obtained by dropping the restriction <script type="math/tex">x \in \mathbb {Z}^ n</script>, replacing it with <script type="math/tex">x \in \mathbb {R}^ n</script>. Essentially, we pretend that an integer linear program is a standard linear program. This can be solved by the simplex method as before. 
</p>
<p>
Unfortunately, solutions of the relaxation problem can be a long way from the optimal solution of the integer linear program. If the feasible region near the optimal solution <script type="math/tex">x^*</script> to the relaxation problem is “long and thin”, then points on the integer lattice surrounding <script type="math/tex">x^*</script> can easily be infeasible. It is possible to construct cases where the difference in the objective function value between the integer linear program and it relaxation problem are arbitrarily large. This is illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:ilp:relaxation">5.2</a>. 
</p>
<figure id="fig:ilp:relaxation">
<p>
<img alt="A pathological integer linear program. The feasible region of the standard problem (blue shaded region) is “long and thin”. The integer solutions (blue dots) that neighbour the solution to the standard problem (red dot) are not close to any feasible solution to the integer problem (green dots)." src="../../notes/course_notes/images/img-0034.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">5.2</span>
<span class="caption_text">A pathological integer linear program. The feasible region of the standard problem (blue shaded region) is “long and thin”. The integer solutions (blue dots) that neighbour the solution to the standard problem (red dot) are not close to any feasible solution to the integer problem (green dots).</span>
</figcaption>
</figure>
<p>
Typical methods for solving integer problems do use the simplex method to solve linear programs, typically applied to many pieces of the feasible region individually (later courses will cover this). The simplex method remains a key building block. 
</p>
</section><section class="section">
<h2 id="a0000000414">5.2 Total unimodularity</h2>
<section class="subsection">
<h3 id="a0000000415">5.2.1 When relaxation works</h3>
<p>
There are, however, problems where the relaxation problem works. Consider the problem 
</p>
<div class="eqn" id="a0000000416">
<script type="math/tex; mode=display">\begin{equation}\begin{array}{l@{\quad }rcl} \min &  c x & & \\ \text{subject to} &  A x &  = &  b \\ &  x &  \ge &  0 \\ &  x &  \in &  \mathbb {Z}^ n, \end{array}\tag{5.4}\end{equation}</script>
</div>
<p>
 where <script type="math/tex">b \in \mathbb {Z}^ n</script>. This can be constructed by scaling each row of <script type="math/tex">A x = b</script> to make <script type="math/tex">b</script> integer. 
</p>
<p>
Consider the relaxation problem where all restrictions are dropped. For any optimal (basic) solution of the relaxation problem we have 
</p>
<div class="eqn" id="a0000000417">
<script type="math/tex; mode=display">\begin{equation}x_ B = A_ B^{-1} b, \quad x_ N = 0.\tag{5.5}\end{equation}</script>
</div>
<p>
 We have that <script type="math/tex">b</script> is integer. If <script type="math/tex">A_ B^{-1}</script> is also integer it follows that <script type="math/tex">x_ B</script> is integer. Therefore the solution to the linear program is also a solution to the <em>integer</em> linear program, and the simplex method will work. 
</p>
</section><section class="subsection">
<h3 id="a0000000418">5.2.2 Total unimodularity</h3>
<p>
We want some criteria that checks when the inverse of a matrix is integer, without having to compute it and enumerate the entries. We say that a matrix <script type="math/tex">A \in \mathbb {R}^{m \times n}</script> is called <em>total unimodular</em> if the determinant of all its square submatrices takes values in <script type="math/tex">\{ -1, 0, 1\} </script>. 
</p>
<p>
<div class="thmwrapper thm_thmwrapper" id="a0000000419">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">2.1</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
If <script type="math/tex">A</script> is total unimodular then <script type="math/tex">A_ B^{-1}</script> is integer. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000420">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
The inverse of <script type="math/tex">A_ B</script> can be written as 
</p>
<div class="eqn" id="a0000000421">
<script type="math/tex; mode=display">\begin{equation}A_ B^{-1} = \frac{1}{\det (A_ B)} \begin{pmatrix}  \alpha _{1 B_1} 

&  \dots 

&  \alpha _{1 B_ m} 

\\ \vdots 

&  \ddots 

&  \vdots 

\\ \alpha _{m B_1} 

&  \dots 

&  \alpha _{m B_ m} 

\end{pmatrix},\tag{5.6}\end{equation}</script>
</div>
<p>
 where <script type="math/tex">\alpha _{ij} = (-1)^{i+j} \det (M_{ij})</script> and <script type="math/tex">M_{ij}</script> is the submatrix obtained from <script type="math/tex">A_ B</script> by deleting row <script type="math/tex">i</script> and column <script type="math/tex">j</script>. 
</p>
<p>
Since <script type="math/tex">A</script> is total unimodular <script type="math/tex">\det (M_{ij}) \in \{ -1, 0, 1\} </script> and hence <script type="math/tex">\alpha _{ij} \in \{ -1, 0, 1\} </script>, and also <script type="math/tex">\frac{1}{\det (A_ B)} \in \{ -1, 0, 1\} </script>. Therefore <script type="math/tex">A_ B^{-1}</script> is integer. 
</p>
</div>
</div>
<p>
It is possible to frame the shortest path problem as an integer linear program, and to prove that the constraint matrix <script type="math/tex">A</script> is total unimodular so that it can be solved using the simplex method. However, more efficient methods are available as we will see next.  
</p>
</section>
</section><!-- Latex Chapter/Part -->
<h1 id="chap:graphs">Graphs</h1>
<section class="section">
<h2 id="a0000000422">6.1 Introduction</h2>
<p>
The idea of a graph (not in the figure or plotting sense, but as a structure) was introduced in the <script type="math/tex">18^{\text{th}}</script> century to ask questions about paths. The idea now appears everywhere, but transport maps remain one of the key examples. A graph will abstract away all of the details and only show destinations (usually as points) and connecting paths between destinations (usually as lines), together with minimal extra information (such as the distance along a path, or the cost to travel along it). 
</p>
<p>
The mathematical structure can be used to answer a number of detailed questions, but one key question is fundamental. Given a graph with paths linked to distances, what is the shortest distance between two given points? 
</p>
</section><section class="section">
<h2 id="a0000000423">6.2 Directed graphs</h2>
<p>
The mathematical definition of a <em>(directed) graph</em> is the ordered pair <script type="math/tex">G = (V, A)</script>, where the sets are 
</p>
<ul class="itemize" id="a0000000424">
<li id="a0000000425"> <p>
the set of <em>vertices</em> (or <em>nodes</em>) <script type="math/tex">V</script>, with <script type="math/tex">|V| = n</script>; 
</p>
</li>
<li id="a0000000426"> <p>
a set of ordered pairs <script type="math/tex">A \subseteq V \times V</script>, excluding self loops, called <em>arcs</em>, with <script type="math/tex">|A| = m</script>. 
</p>
</li>
</ul>
<p>
 Given an arc <script type="math/tex">(i, j) \in A</script>, the node <script type="math/tex">i</script> is called the <em>tail</em> and node <script type="math/tex">j</script> the <em>head</em>. In a directed graph, travel is only possible from the tail to the head (so imagine drawing an arrow on the arc). 
</p>
<p>
We have not explicitly said what space the nodes are drawn from. In general it does not matter. When giving mathematical examples it is typical to use the natural numbers, so <script type="math/tex">V = \{  1, \dots , n \} </script>, and the node number labels the destination. When thinking about concrete transport examples, it can make more sense to use a name or an alphanumeric code. A simple directed graph using integers is illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:graph:intro">6.1</a>. 
</p>
<figure id="fig:graph:intro">
<p>
<img alt="A simple directed graph. The vertices or nodes are the circles, here labelled by natural numbers. The edges are illustrated as arrows." src="../../notes/course_notes/images/img-0036.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">6.1</span>
<span class="caption_text">A simple directed graph. The vertices or nodes are the circles, here labelled by natural numbers. The edges are illustrated as arrows.</span>
</figcaption>
</figure>
<section class="subsection">
<h3 id="a0000000427">6.2.1 Definitions</h3>
<p>
We call a node <script type="math/tex">j \in V</script> <em>adjacent</em> to another node <script type="math/tex">i \in V</script> if <script type="math/tex">(i, j) \in A</script>. As, by construction, there are no self-loops allowed, a node cannot be adjacent to itself. 
</p>
<p>
We call an arc <script type="math/tex">a \in A</script> <em>incident</em> to a node <script type="math/tex">j \in V</script> if <script type="math/tex">a = (i, j)</script> for some node <script type="math/tex">i \in V</script>. So an arc is incident on a node if there is some other node in the graph that uses the arc to move to the node. 
</p>
<p>
We call a directed graph <script type="math/tex">G</script> <em>complete</em> if <script type="math/tex">A</script> contains an arc for each distinct pair of nodes, 
</p>
<div class="eqn" id="a0000000428">
<script type="math/tex; mode=display">\begin{equation}A = \left\{  (i, j) \colon \forall i \in V, j \in V, i \ne j \right\} .\tag{6.1}\end{equation}</script>
</div>
<p>
 If the graph is complete we can immediately travel from any node to any other node using just one arc. 
</p>
</section><section class="subsection">
<h3 id="a0000000429">6.2.2 Number of arcs</h3>
<p>
<div class="thmwrapper thm_thmwrapper" id="a0000000430">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">2.1</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
In any directed graph, <script type="math/tex">m \le n (n - 1)</script>, with <script type="math/tex">m = n (n - 1)</script> in the complete case. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000431">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
In the complete case, each of the <script type="math/tex">n</script> nodes is adjacent to all of the other <script type="math/tex">(n - 1)</script> nodes: we have <script type="math/tex">m = n (n - 1)</script> arcs. 
</p>
<p>
If the graph is not complete, some arcs are missing. Hence <script type="math/tex">m \le n (n - 1)</script>. 
</p>
</div>
</div>
<p>
We called a directed graph <em>sparse</em> if <script type="math/tex">m \ll n (n - 1)</script>. 
</p>
</section><section class="subsection">
<h3 id="a0000000432">6.2.3 Paths</h3>
<p>
If the graph is not complete then traversing a single arc may not be enough to get us from our start point to the desired end point. Instead we may have to traverse multiple arcs. 
</p>
<p>
We define a <em>path</em> as a sequence 
</p>
<div class="eqn" id="a0000000433">
<script type="math/tex; mode=display">\begin{equation}P = (i_1, i_2), (i_2, i_3), \dots , (i_{k-1}, i_ k), (i_ k, i_{k+1})\tag{6.2}\end{equation}</script>
</div>
<p>
 of <script type="math/tex">k \ge 1</script> consecutive and distinct arcs. Note that the head of each arc in the sequence matches the tail of the next arc, making the arcs consecutive. 
</p>
<p>
Given a path, we say that a node <script type="math/tex">v \in V</script> is <em>connected</em> to a node <script type="math/tex">w \in V</script> if there is a path <script type="math/tex">P</script> with <script type="math/tex">i_1 = v</script> and <script type="math/tex">i_{k+1} = w</script>. 
</p>
<p>
Finally, we say that a graph is <em>connected</em> if every pair of its nodes is connected. This is illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:graph:connected">6.2</a>. 
</p>
<figure id="fig:graph:connected">
<p>
<img alt="The graph on the left is connected but not complete. The graph on the right is not connected, as no edge goes in to node 1." src="../../notes/course_notes/images/img-0038.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">6.2</span>
<span class="caption_text">The graph on the left is connected but not complete. The graph on the right is not connected, as no edge goes in to node <script type="math/tex">1</script>.</span>
</figcaption>
</figure>
</section><section class="subsection">
<h3 id="a0000000434">6.2.4 Cuts</h3>
<p>
So far everything has been set either at the level of individual nodes or at the level of the whole graph. For building algorithms that allow us to analyse paths as they move through the graph, we need to look at subsets of the graph, and how we might move into or out of those subsets. 
</p>
<p>
Let <script type="math/tex">S \subseteq V</script> be some part of graph (by looking at some suset of the vertices). We define the <em>forward cut induced by <script type="math/tex">S</script></em> to be the set of arcs “leaving <script type="math/tex">S</script>”. That is 
</p>
<div class="eqn" id="a0000000435">
<script type="math/tex; mode=display">\begin{equation}\delta ^+(S) = \left\{  (i, j) \in A \colon i \in S \text{ and } j \in V \setminus S \right\} .\tag{6.3}\end{equation}</script>
</div>
<p>
 Similarly, we define the <em>backward cut induced by <script type="math/tex">S</script></em> to be the set of arcs “entering <script type="math/tex">S</script>”. That is 
</p>
<div class="eqn" id="a0000000436">
<script type="math/tex; mode=display">\begin{equation}\delta ^+(S) = \left\{  (i, j) \in A \colon i \in V \setminus S \text{ and } j \in S \right\} .\tag{6.4}\end{equation}</script>
</div>
<p>
 These are illustrated in figure <a class="ref" href="../../notes/course_notes/index.html#fig:graph:cuts">6.3</a>. 
</p>
<figure id="fig:graph:cuts">
<p>
<img alt="The set S={4, 5} is shaded in blue. Its forward cut δ+(S) is every edge (highlighted in blue in the left plot) that leaves S. Its backward cut δ-(S) is every edge (highlighted in green in the right plot) that enters S." src="../../notes/course_notes/images/img-0040.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">6.3</span>
<span class="caption_text">The set <script type="math/tex">S=\{ 4, 5\} </script> is shaded in blue. Its forward cut <script type="math/tex">\delta ^+(S)</script> is every edge (highlighted in blue in the left plot) that leaves <script type="math/tex">S</script>. Its backward cut <script type="math/tex">\delta ^-(S)</script> is every edge (highlighted in green in the right plot) that enters <script type="math/tex">S</script>.</span>
</figcaption>
</figure>
<p>
Of course, we can apply these definitions to the case to single nodes, by setting <script type="math/tex">S = \{  i \} </script> for any node <script type="math/tex">i \in V</script>. These have special names: the <em>forward star</em> of the node <script type="math/tex">i</script> is <script type="math/tex">\delta ^+(i)</script>, whilst the <em>backward star</em> of the node <script type="math/tex">i</script> is <script type="math/tex">\delta ^-(i)</script>. The sizes of these sets also have special names, with the <em>out-degree</em> of node <script type="math/tex">i</script> being <script type="math/tex">|\delta ^+(i)|</script>, and the <em>in-degree</em> of node <script type="math/tex">i</script> being <script type="math/tex">|\delta ^-(i)|</script>. 
</p>
</section><section class="subsection">
<h3 id="a0000000437">6.2.5 Representations</h3>
<p>
So far we have represented the graph using the vertices <script type="math/tex">V</script> and the arcs <script type="math/tex">A</script>. However, as in the linear programming case, there are multiple ways of representing the problem, each of which has its own advantages. 
</p>
<p>
For simplicity these additional representations will assume that <script type="math/tex">V</script> is given by consecutive integers labelling the nodes. Depending on choice these can either start from <script type="math/tex">1</script> (so <script type="math/tex">V = \{  1, \dots , n \} </script>) or <script type="math/tex">0</script> (so <script type="math/tex">V = \{  0, \dots , n-1 \} </script>). The latter is more natural for a Python implementation, but the former more natural in many mathematical texts. With this assumption we only need to consider different representations of the arcs, <script type="math/tex">A</script>. 
</p>
<section class="subsubsection">
<h4 id="a0000000438">Adjacency list</h4>
<p>
In the <em>adjacency list</em> approach we construct a list <script type="math/tex">L</script> of size <script type="math/tex">n</script>. Each component of the list <script type="math/tex">L_ i</script> contains a list of size at most <script type="math/tex">n-1</script>, containing the indices of the nodes adjacent to <script type="math/tex">i</script>. In terms of the stars, we have 
</p>
<div class="eqn" id="a0000000439">
<script type="math/tex; mode=display">\begin{equation}L_ i = \{  j \colon (i, j) \in \delta ^*(i) \} .\tag{6.5}\end{equation}</script>
</div>
<p>
 The advantage of the adjacency list approach is that it is easy to use to navigate the graph. The component <script type="math/tex">L_ i</script> gives every node that is reachable from node <script type="math/tex">i</script> using a single arc. 
</p>
</section><section class="subsubsection">
<h4 id="a0000000440">Adjacency matrix</h4>
<p>
In the <em>adjacency matrix</em> approach we construct a single matrix of size <script type="math/tex">n \times n</script> that contains only zeros and ones. The matrix entry is one if the associated arc exists and zero otherwise. Explicitly, 
</p>
<div class="eqn" id="a0000000441">
<script type="math/tex; mode=display">\begin{equation}m_{ij} = \begin{cases}  1 &  \text{if } (i, j) \in A \\ 0 &  \text{otherwise} \end{cases}.\tag{6.6}\end{equation}</script>
</div>
<p>
 The adjacency matrix is less efficient for navigating the graph, but more efficient if we need to check if an arc exists. 
</p>
</section>
</section>
</section><section class="section">
<h2 id="a0000000442">6.3 Shortest paths</h2>
<p>
Now that we have the terminology to represent and discuss graphs, we want to turn the word problem “Find the shortest path connecting two points” into something precise. 
</p>
<section class="subsection">
<h3 id="a0000000443">6.3.1 The problem</h3>
<p>
The <em>shortest path problem</em> is as follows. Given a directed graph <script type="math/tex">G = (V, A)</script> with a (non-negative) length function <script type="math/tex">l \colon A \to \mathbb {R}^+</script> and two nodes <script type="math/tex">s, t \in V</script>, find an <script type="math/tex">s-t</script> path of shortest total length. 
</p>
<p>
The length function tells us the distance along any one single arc: equivalently, the distance between any two nodes or vertices when moving in a specific direction. This need not be the same in both directions (hence the notion of a <em>directed</em> graph): think about one-way streets, for example. As a notational shortcut we will often talk about lengths of paths in addition to lengths of arcs. As a path is a sequence of consecutive arcs without loops and the length function is non-negative, it follows that 
</p>
<div class="eqn" id="a0000000444">
<script type="math/tex; mode=display">\begin{equation}l(P) = \sum _{a \in P} l(a).\tag{6.7}\end{equation}</script>
</div>
<p>
 If the arc <script type="math/tex">a = (i, j)</script> then sometimes the notation <script type="math/tex">l_{ij} = l((i, j)) = l(a)</script> is used, and so we can write 
</p>
<div class="eqn" id="a0000000445">
<script type="math/tex; mode=display">\begin{equation}l(P) = \sum _{(i, j) \in P} l_{ij}.\tag{6.8}\end{equation}</script>
</div>
<p>
The two nodes in the problem are the <em>source</em> node <script type="math/tex">s</script> from which we start and the <em>target</em> node <script type="math/tex">t</script> that we are trying to get to. 
</p>
<p>
There is a generalisation of the problem which is, in fact, no harder to solve. The <em>single source shortest path problem</em> is as follows. Given a directed graph <script type="math/tex">G = (V, A)</script> with a (non-negative) length function <script type="math/tex">l \colon A \to \mathbb {R}^+</script> and one node <script type="math/tex">s \in V</script>, find a path between <script type="math/tex">s</script> and every other node in <script type="math/tex">V \setminus \{  s \} </script> of shortest total length. 
</p>
<p>
We note that it only makes sense to solve the shortest path problem if the source and target nodes are connected. Therefore it only makes sense to solve the single source shortest path problem if the entire graph is connected. Throughout the rest of this chapter we will assume that the graph is connected. 
</p>
<figure id="fig:graph:shortest:intro">
<p>
<img alt="A graph with its shortest path. Each node is annotated with its label (a natural number here). Each edge (i, j) is annotated with its length lij. The bold lines show the shortest 0-5 path, P=(0,3),(3,2),(2,5)." src="../../notes/course_notes/images/img-0042.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">6.4</span>
<span class="caption_text">A graph with its shortest path. Each node is annotated with its label (a natural number here). Each edge <script type="math/tex">(i, j)</script> is annotated with its length <script type="math/tex">l_{ij}</script>. The bold lines show the shortest <script type="math/tex">0-5</script> path, <script type="math/tex">P=(0,3),(3,2),(2,5)</script>.</span>
</figcaption>
</figure>
</section><section class="subsection">
<h3 id="a0000000446">6.3.2 Subpath optimality</h3>
<p>
The key result in finding the shortest path is intuitively stated as “shortest paths are composed of shortest paths”. This seems either obvious or trivial. The precise result is <div class="thmwrapper thm_thmwrapper" id="a0000000447">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">3.1</span>
<span class="thmtitle thm_thmtitle">(Subpath Optimality)</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
 Let <script type="math/tex">P = (i_1, i_2), (i_2, i_3), \dots , (i_{k-1}, i_ k)</script> be an <script type="math/tex">i_1-i_ k</script> shortest path. For any pair of nodes <script type="math/tex">i_ u, i_ v</script> visited by <script type="math/tex">P</script>, with <script type="math/tex">u < v</script>, the subpath <script type="math/tex">S</script> from <script type="math/tex">i_ u</script> to <script type="math/tex">i_ v</script> is a shortest <script type="math/tex">i_ u-i_ v</script> path. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000448">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
This follows by contradiction. if <script type="math/tex">S</script> is not a shortest <script type="math/tex">i_ u-i_ v</script> path then there is another <script type="math/tex">i_ u-i_ v</script> path <script type="math/tex">S'</script> that is strictly shorter than <script type="math/tex">S</script>, <script type="math/tex">l(S') < l(S)</script>. We can therefore define a new <script type="math/tex">i_1-i_ k</script> path <script type="math/tex">P'</script> by using the “shortcut” <script type="math/tex">S'</script>, 
</p>
<div class="eqn" id="a0000000449">
<script type="math/tex; mode=display">\begin{equation}P' = P \setminus S \cup S'.\tag{6.9}\end{equation}</script>
</div>
<p>
 From the positivity of the length function it immediately follows that 
</p>
<div class="eqn" id="a0000000450">
<script type="math/tex; mode=display">\begin{equation}l(P') = l(P) - l(S) + l(S') < l(P).\tag{6.10}\end{equation}</script>
</div>
<p>
 Therefore <script type="math/tex">P</script> was not the shortest path, and we have a contradiction. 
</p>
</div>
</div>
<p>
 The original characterisation can now be more precisely stated as “every subpath of a shortest path is itself a shortest path”. 
</p>
</section>
</section><section class="section">
<h2 id="a0000000451">6.4 Dijkstra’s theorem</h2>
<p>
This is the central result that allow us to build an algorithm to solve the shortest path problem. <div class="thmwrapper thm_thmwrapper" id="a0000000452">
<div class="thmheading thm_thmheading">
<span class="thmcaption thm_thmcaption">
    Theorem
    </span>
<span class="thmlabel thm_thmlabel">4.1</span>
<span class="thmtitle thm_thmtitle">(Dijkstra’s theorem)</span>
</div>
<div class="thmcontent thm_thmcontent">
<p>
 Let <script type="math/tex">S \subseteq V</script> be a subset of the vertices that contains the source <script type="math/tex">s</script>. Let <script type="math/tex">Y(i)</script>, for all <script type="math/tex">i \in V</script>, be the length of the corresponding shortest <script type="math/tex">s-i</script> path. Let 
</p>
<div class="eqn" id="a0000000453">
<script type="math/tex; mode=display">\begin{equation}(v, w) \in \operatorname*{argmin}_{(i, j) \in \delta ^+(S)} \left[ Y(i) + l_{ij} \right].\tag{6.11}\end{equation}</script>
</div>
<p>
 Then <script type="math/tex">\varphi = P_{(s-v)} \cup \{  (v, w) \} </script> is a shortest <script type="math/tex">s-w</script> path, where <script type="math/tex">P_{(s-v)}</script> is a shortest <script type="math/tex">s-v</script> path. 
</p>
</div>
</div>
</p>
<div class="proof_wrapper" id="a0000000454">
<div class="proof_heading">
<span class="proof_caption">
    Proof.
    </span>
</div>
<div class="proof_content">
<p>
We show that any other path <script type="math/tex">\pi </script> to any other vertex <script type="math/tex">u \in V \setminus S</script> has either the same length as <script type="math/tex">\varphi </script> or a strictly larger one. 
</p>
<p>
First, decompose the path <script type="math/tex">\pi </script> as 
</p>
<div class="eqn" id="a0000000455">
<script type="math/tex; mode=display">\begin{equation}\pi = \pi _1 \cup \{  (i, j) \}  \cup \pi _2,\tag{6.12}\end{equation}</script>
</div>
<p>
 where <script type="math/tex">i \in S</script>, <script type="math/tex">j \in V \setminus S</script>, <script type="math/tex">\pi _1</script> is a shortest <script type="math/tex">s-i</script> path, <script type="math/tex">(i, j) \in \delta ^+(S)</script>, and <script type="math/tex">\pi _2</script> is a shortest <script type="math/tex">j-u</script> path. This is always possible due to the subpath optimality theorem. It allows us to concentrate on the arc <script type="math/tex">(i, j)</script> that leaves the set <script type="math/tex">S</script>. It follows that 
</p>
<div class="eqn" id="a0000000456">
<script type="math/tex; mode=display">\begin{equation}l(\pi ) = l(\pi _1) + l_{ij} + l(\pi _2).\tag{6.13}\end{equation}</script>
</div>
<p>
Since we have chosen <script type="math/tex">(v, w) \in \delta ^+(S)</script> to minimise <script type="math/tex">Y(i) + l_{ij}</script> it must be true that 
</p>
<div class="eqn" id="a0000000457">
<script type="math/tex; mode=display">\begin{equation}l(\pi _1) + l_{ij} \ge Y(v) + l_{vw}.\tag{6.14}\end{equation}</script>
</div>
<p>
 Since <script type="math/tex">l(\pi _2) \ge 0</script> it follows that 
</p>
<div id="a0000000458">
<div class="eqnarrayid" id="a0000000459"></div><div class="eqnarrayid" id="a0000000460"></div><div class="eqnarrayid" id="a0000000461"></div><div class="eqnarrayid" id="a0000000462"></div><script type="math/tex; mode=display">
\begin{align}
\tag{6.15} l(\pi ) & = l(\pi _1) + l_{ij} + l(\pi _2) \\ 
\tag{6.16}& \ge l(\pi _1) + l_{ij} \\ 
\tag{6.17}& \ge Y(v) + l_{vw} \\ 
\tag{6.18}& = l(\varphi ). 
\end{align}
</script>
</div>
<p>
 Therefore <script type="math/tex">l(\pi ) \ge l(\varphi )</script> for all such paths, and therefore <script type="math/tex">\varphi </script> is a shortest <script type="math/tex">s-w</script> path. 
</p>
</div>
</div>
<figure id="fig:graph:dijkstra:proof">
<p>
<img alt="The key idea used in proving Dijkstra’s theorem. We want to show that the shortest path from s to w is given by the shortest s-v path (already found an in S, by assumption) linked to the v-w edge. This must be true if the length of this path is no greater than the length of any other path connecting any point not in S to s." src="../../notes/course_notes/images/img-0044.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">6.5</span>
<span class="caption_text">The key idea used in proving Dijkstra’s theorem. We want to show that the shortest path from <script type="math/tex">s</script> to <script type="math/tex">w</script> is given by the shortest <script type="math/tex">s-v</script> path (already found an in <script type="math/tex">S</script>, by assumption) linked to the <script type="math/tex">v-w</script> edge. This must be true if the length of this path is no greater than the length of any other path connecting any point not in <script type="math/tex">S</script> to <script type="math/tex">s</script>.</span>
</figcaption>
</figure>
<section class="subsection">
<h3 id="a0000000463">6.4.1 Dijkstra’s algorithm</h3>
<p>
We can now use subpath optimality and iteratively apply Dijkstra’s theorem to give us an algorithm. Starting from the source node, we keep adding nodes to the set of nodes we have “seen” so that we have the shortest path in that set. 
</p>
<p>
Being more precise, but still sketching in words. We want to find the shortest path from the source node <script type="math/tex">s</script> to every other node in the graph. We construct a set <script type="math/tex">S \subseteq V</script>, starting from <script type="math/tex">S = \{  s \} </script>, of all the nodes we have so far “seen”. We also need two <em>labels</em>. The first is <script type="math/tex">Y(i)</script>, the shortest path length from <script type="math/tex">s</script> to <script type="math/tex">i</script>. The second is <script type="math/tex">P(i)</script>, the predecessor of <script type="math/tex">i</script> in the <script type="math/tex">s-i</script> path. At the start <script type="math/tex">Y(s) = 0</script> and <script type="math/tex">P(s)</script> is undefined (as it makes no sense). 
</p>
<p>
We then iterate as long as <script type="math/tex">|S| < n</script>, so that <script type="math/tex">V \setminus S</script> is not empty. For each iteration we 
</p>
<ol class="enumerate" id="a0000000464" style="list-style: none">
<li id="a0000000465" value="1">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		1.
	</span>
<p>
find <script type="math/tex">(v, w) \in \delta ^+(s)</script> that minimises <script type="math/tex">Y(v) + l_{vw}</script>; 
</p>
</li>
<li id="a0000000466" value="2">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		2.
	</span>
<p>
set <script type="math/tex">Y(w) = Y(v) + l_{vw}</script>; 
</p>
</li>
<li id="a0000000467" value="3">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		3.
	</span>
<p>
set <script type="math/tex">P(w) = v</script>; 
</p>
</li>
<li id="a0000000468" value="4">
<span style="transform: translateX(-100%);padding-right: 10px;position: absolute;">
		4.
	</span>
<p>
set <script type="math/tex">S \to S \cup \{  w \} </script>. 
</p>
</li>
</ol>
<p>
 Note that, for every node <script type="math/tex">i</script>, the shortest path length from the source <script type="math/tex">Y(i)</script> adn the predecessor node on the shortest path <script type="math/tex">P(i)</script> are set only once, when the final shortest arc to <script type="math/tex">i</script> is found and <script type="math/tex">i</script> is added to <script type="math/tex">S</script>. 
</p>
<p>
This solves the <em>single source</em> shortest path problem. To solve the shortest path problem when the target <script type="math/tex">t</script> is specified we can check to see if <script type="math/tex">w = t</script> and, if so, stop at the end of that iteration. This makes no difference to the code complexity as, in the worst case that has to be considered, <script type="math/tex">t</script> will be the last node added to <script type="math/tex">S</script>. 
</p>
</section><section class="subsection">
<h3 id="a0000000469">6.4.2 Representing the length</h3>
<p>
We have seen multiple methods for representing the topology of the graph, each of which has their individual advantages. As Dijkstra’s algorithm depends crucially on minimising a length and looking up <script type="math/tex">l_{vw}</script>, it is important to have an easy and efficient way of representing the arc lengths. 
</p>
<section class="subsubsection">
<h4 id="a0000000470">Adjacency list</h4>
<p>
As in the graph case, we construct a list <script type="math/tex">L_ l</script> of size <script type="math/tex">n</script>, where each component <script type="math/tex">i</script> contains another list of size at most <script type="math/tex">n-1</script>, containing the <em>lengths</em> of all arcs <script type="math/tex">(i, j) \in \delta ^+(i)</script>, in order of index <script type="math/tex">j</script>. 
</p>
<p>
This representation needs the adjacency list <script type="math/tex">L</script> as well in order to give the index <script type="math/tex">j</script>. Assuming that <script type="math/tex">V</script> is a set of consecutive integers of size <script type="math/tex">n</script>, the whole graph (including arc length information) is given once <script type="math/tex">L, L_ l</script> are given. The size of the graph <script type="math/tex">n</script> is implicit in the length of the lists. 
</p>
</section><section class="subsubsection">
<h4 id="a0000000471">Adjacency matrix</h4>
<p>
Again this is similar to the graph case. We construct a matrix <script type="math/tex">M_ l \in \left\{  \mathbb {R} \cup \{  \infty \}  \right\} ^{n \times n}</script> where, for each <script type="math/tex">i, j \in V</script>, the component <script type="math/tex">(m_ l)_{ij}</script> is the length of the <script type="math/tex">(i, j)</script> arc, or is infinity if no such arc exists. 
</p>
<p>
This representation implicitly stores all the information about the graph, including its topology, so the adjacency matrix <script type="math/tex">M</script> is not needed. 
</p>
</section>
</section><section class="subsection">
<h3 id="a0000000472">6.4.3 Implementing Dijkstra’s algorithm</h3>
<p>
The adjacency list form is the most efficient for checking whether an arc exists. The adjacency matrix form is the most efficient for checking what the length of the arc is. We assume that we are not limited by the amount of memory that each form takes, so we will use both forms in our implementation. In the code snippet below, <span class="ttfamily">L</span> is the adjacency list representing the topology of the graph and <span class="ttfamily">Ml</span> is the adjacency matrix representation of the length function. 
</p>
<div class="highlight"><pre><span></span><span class="linenos"> 1</span>S = [s]
<span class="linenos"> 2</span>Y = np.empty(n)  # Value does not matter
<span class="linenos"> 3</span>P = np.empty(n)  # Only size matters
<span class="linenos"> 4</span>Y[s] = 0
<span class="linenos"> 5</span>while len(S) &lt; n:
<span class="linenos"> 6</span>    min_Y = np.inf
<span class="linenos"> 7</span>    v, w = -1, -1
<span class="linenos"> 8</span>    for i in S:
<span class="linenos"> 9</span>        if j in S:  # Only consider arcs leaving S
<span class="linenos">10</span>            continue
<span class="linenos">11</span>        if min_Y &gt; Y[i] + Ml[i][j]:
<span class="linenos">12</span>            min_Y = Y[i] + Ml[i][j]
<span class="linenos">13</span>            v, w = i, j
<span class="linenos">14</span>    Y[w] = Y[v] + Ml[v][w]
<span class="linenos">15</span>    P[w] = v
<span class="linenos">16</span>    S.append(w)
</pre></div>
</section><section class="subsection">
<h3 id="a0000000473">6.4.4 Complexity</h3>
<p>
To compute the complexity we consider the order of each line or block of the code above. We have 
</p>
<ul class="itemize" id="a0000000474">
<li id="a0000000475"> <p>
Line 1 writes a single value, taking <script type="math/tex">\mathcal{O}(1)</script>; 
</p>
</li>
<li id="a0000000476"> <p>
Lines 2-3 write <script type="math/tex">n</script> values, taking <script type="math/tex">\mathcal{O}(n)</script> each; 
</p>
</li>
<li id="a0000000477"> <p>
Line 4 writes a single value, taking <script type="math/tex">\mathcal{O}(1)</script>; 
</p>
</li>
<li id="a0000000478"> <p>
Line 5 loops over the whole graph, so is executed <script type="math/tex">n</script> times. Each block takes: 
</p>
<ul class="itemize" id="a0000000479">
<li id="a0000000480"> <p>
Lines 6-7 write single values, taking <script type="math/tex">\mathcal{O}(1)</script>; 
</p>
</li>
<li id="a0000000481"> <p>
Lines 8-10 correspond to looping over <script type="math/tex">\delta ^+(S)</script> in its entirety. This is executed <script type="math/tex">m</script> times, where <script type="math/tex">m</script> is the out degree of <script type="math/tex">S</script>. Earlier results show <script type="math/tex">m \le n (n - 1)</script>. In the worst case <script type="math/tex">m = \mathcal{O}(n^2)</script>. Each block takes: 
</p>
<ul class="itemize" id="a0000000482">
<li id="a0000000483"> <p>
Lines 11-13 are single comparisons or single writes, each taking <script type="math/tex">\mathcal{O}(1)</script>; 
</p>
</li>
</ul>
<p>
 Therefore this inner loop has complexity <script type="math/tex">\mathcal{O}(m) = \mathcal{O}(n^2)</script>. 
</p>
</li>
<li id="a0000000484"> <p>
Lines 14-16 are single writes, each taking <script type="math/tex">\mathcal{O}(1)</script>; 
</p>
</li>
</ul>
<p>
 Therefore this outer loop has complexity <script type="math/tex">\mathcal{O}(n) \mathcal{O}(n^2) = \mathcal{O}(n^3)</script>. 
</p>
</li>
</ul>
<p>
 Therefore the whole algorithm has complexity <script type="math/tex">\mathcal{O}(n^3)</script>. 
</p>
<p>
This is considerably faster than the complexity of the simplex algorithm (in its worst case). 
</p>
</section><section class="subsection">
<h3 id="a0000000485">6.4.5 A faster method</h3>
<p>
Finding the shortest path is a sufficiently important practical problem that we want to find an algorithm faster than <script type="math/tex">\mathcal{O}(n^3)</script>. This can be done. The key issue is that by repeatedly scanning <script type="math/tex">\delta ^*(S)</script> we are recomputing particular shortest path lengths multiple times. With additional structures we can reduce that computation. 
</p>
<p>
We need the following observation: 
</p>
<div id="a0000000486">
<div class="eqnarrayid" id="a0000000487"></div><div class="eqnarrayid" id="a0000000488"></div><script type="math/tex; mode=display">
\begin{align}
\tag{6.19}& &  (v, w) & \in \operatorname*{argmin}_{(i, j) \in \delta ^+(S)} \left\{  Y(i) + l_{ij} \right\}  \\ 
\tag{6.20}\iff & &  (v, w)& \in \operatorname*{argmin}_{j \in V \setminus S} \left\{  \operatorname*{argmin}_{(i, j) \in \delta ^-(S) \colon i \in S} \left\{  Y(i) + l_{ij} \right\}  \right\} . 
\end{align}
</script>
</div>
<p>
 The point here is that if we already know, for given node <script type="math/tex">j \in V \setminus S</script>, which arc minimises <script type="math/tex">Y(i) + l_{ij}</script>, then we can find the arc <script type="math/tex">(v, w)</script> giving the shortest path by looking at the <script type="math/tex">\mathcal{O}(n)</script> vertices <script type="math/tex">j \in V \setminus S</script>, rather than looking at the <script type="math/tex">\mathcal{O}(m) = \mathcal{O}(n^2)</script> arcs in <script type="math/tex">\delta ^+(S)</script>. 
</p>
<figure id="fig:graph:dijkstra:n2:idea">
<p>
<img alt="The key idea used in constructing the faster O(n2) version of Dijkstra’s algorithm. When trying to add to the set S (blue shaded region) we must compute the shortest path and predecessors to the points not in S, given the current S (red edges). By storing these values and updating them when needed, instead of re-computing every iteration, we save lots of computation." src="../../notes/course_notes/images/img-0046.png" style="width:469.755pt"/>
</p>
<figcaption>
<span class="caption_title">Figure</span>
<span class="caption_ref">6.6</span>
<span class="caption_text">The key idea used in constructing the faster <script type="math/tex">\mathcal{O}(n^2)</script> version of Dijkstra’s algorithm. When trying to add to the set <script type="math/tex">S</script> (blue shaded region) we must compute the shortest path and predecessors to the points not in <script type="math/tex">S</script>, given the current <script type="math/tex">S</script> (red edges). By storing these values and updating them when needed, instead of re-computing every iteration, we save lots of computation.</span>
</figcaption>
</figure>
<p>
To use this observation to construct an algorithm, we change the way we think about the labels <script type="math/tex">Y(j), P(j)</script>, representing the length of the shortest <script type="math/tex">s-j</script> path and the predecessor index in that shortest path respectively. In the original algorithm they were set <em>only when</em> <script type="math/tex">j</script> enters <script type="math/tex">S</script>. Until that point they had no value, or their value was meaningless. 
</p>
<p>
In the new algorithm, the meaning of the labels will remain the same <em>as long as</em> <script type="math/tex">j \in S</script>. If <script type="math/tex">j \in V \setminus S</script> then the value of <script type="math/tex">Y(j)</script> and <script type="math/tex">P(j)</script> will represent the length and predecessor index of the shortest <script type="math/tex">s-j</script> path found <em>up to the current iteration</em>. At each iteration we will check <em>and update</em> the value of the labels when a new vertex enters <script type="math/tex">S</script>. 
</p>
<div class="highlight"><pre><span></span><span class="linenos"> 1</span>S = [s]
<span class="linenos"> 2</span>Y = np.copy(Ml[s][:])  # These values now matter
<span class="linenos"> 3</span>P = np.zeros(n)        # These also now matter
<span class="linenos"> 4</span>Y[s] = 0
<span class="linenos"> 5</span>while len(S) &lt; n:
<span class="linenos"> 6</span>    min_Y = np.inf
<span class="linenos"> 7</span>    w = -1             # Note: only w, not v
<span class="linenos"> 8</span>    for j in V:        # Note: change here
<span class="linenos"> 9</span>        if j in S:  # Only consider arcs leaving S
<span class="linenos">10</span>            continue
<span class="linenos">11</span>        if min_Y &gt; Y[j]:
<span class="linenos">12</span>            min_Y = Y[j]
<span class="linenos">13</span>            w = j
<span class="linenos">14</span>    S.append(w)
<span class="linenos">15</span>    for h in L[w]:  # New step: update labels
<span class="linenos">16</span>        if h in S:
<span class="linenos">17</span>            continue
<span class="linenos">18</span>        if Y[h] &gt; Y[w] + Ml[w][h]:
<span class="linenos">19</span>            Y[h] = Y[w] + Ml[w][h]
<span class="linenos">20</span>            P[h] = w
</pre></div>
<p>
The explicit complexity calculation is 
</p>
<ul class="itemize" id="a0000000489">
<li id="a0000000490"> <p>
Line 1 writes a single value, taking <script type="math/tex">\mathcal{O}(1)</script>; 
</p>
</li>
<li id="a0000000491"> <p>
Lines 2-3 write <script type="math/tex">n</script> values, taking <script type="math/tex">\mathcal{O}(n)</script> each; 
</p>
</li>
<li id="a0000000492"> <p>
Line 4 writes a single value, taking <script type="math/tex">\mathcal{O}(1)</script>; 
</p>
</li>
<li id="a0000000493"> <p>
Line 5 loops over the whole graph, so is executed <script type="math/tex">n</script> times. Each block takes: 
</p>
<ul class="itemize" id="a0000000494">
<li id="a0000000495"> <p>
Lines 6-7 write single values, taking <script type="math/tex">\mathcal{O}(1)</script>; 
</p>
</li>
<li id="a0000000496"> <p>
Lines 8-10 correspond to looping over <script type="math/tex">V \setminus S</script> in its entirety. In the worst case this is <script type="math/tex">\mathcal{O}(n)</script>. Each block takes: 
</p>
<ul class="itemize" id="a0000000497">
<li id="a0000000498"> <p>
Lines 11-13 are single comparisons or single writes, each taking <script type="math/tex">\mathcal{O}(1)</script>; 
</p>
</li>
</ul>
<p>
 Therefore this inner loop has complexity <script type="math/tex">\mathcal{O}(n)</script>. 
</p>
</li>
<li id="a0000000499"> <p>
Lines 14 is a single write taking <script type="math/tex">\mathcal{O}(1)</script>; 
</p>
</li>
<li id="a0000000500"> <p>
Lines 15-17 correspond to looping over <script type="math/tex">V \setminus S</script> in its entirety again. In the worst case this is <script type="math/tex">\mathcal{O}(n)</script>. Each block takes: 
</p>
<ul class="itemize" id="a0000000501">
<li id="a0000000502"> <p>
Lines 18-20 are single comparisons or single writes, each taking <script type="math/tex">\mathcal{O}(1)</script>; 
</p>
</li>
</ul>
<p>
 Therefore this inner loop has complexity <script type="math/tex">\mathcal{O}(n)</script>. 
</p>
</li>
</ul>
<p>
 Therefore this outer loop has complexity <script type="math/tex">\mathcal{O}(n) \mathcal{O}(n) = \mathcal{O}(n^2)</script>. 
</p>
</li>
</ul>
<p>
 Therefore this algorithm has complexity <script type="math/tex">\mathcal{O}(n^2)</script>. When the graph is large this can be a substantial improvement in efficiency. 
</p>
<p>
Note that this is not the fastest algorithm that exists. It is possible to construct algorithms with complexities <script type="math/tex">\sim \mathcal{O}(n \log (n))</script>.  
</p>
</section>
</section>

            </div>
        </div>
    </div>

        </main>
		
		<footer class="text-muted">
	<hr>
	<div class="container">
		<div class="float-right">
			<ul style="list-style: none">
			<li><a href="#">Back to top</a></li>
			
			
			<li><a href="../../notes/course_notes/pdf/course_notes.pdf" target="_blank"><i class="fa fa-file-pdf-o"></i>&nbsp;Download as PDF</a></li>
			
			</ul>
		</div>
		<p>Generated using <a target="_blank" href="https://github.com/chirun-ncl/chirun">Chirun</a>, written by the E-Learning Unit, School of Mathematics &amp; Statistics, Newcastle University</p>
		<p>This page last generated: 2022-01-20</p>
	</div>
</footer>
		
    </body>
</html>
